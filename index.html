<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Dark Theme</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #0a0a0a;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%);
            min-height: 100vh;
            color: #e0e6ed;
            overflow-x: hidden;
            position: relative;
        }
        
        /* ÁÆÄÂåñÁöÑÂä®ÊÄÅËÉåÊôØÊïàÊûú */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.1), transparent),
                radial-gradient(1px 1px at 40px 70px, rgba(0,255,255,0.05), transparent);
            background-size: 100px 80px;
            animation: sparkle 20s linear infinite;
            pointer-events: none;
            z-index: 1;
            opacity: 0.5;
        }
        
        @keyframes sparkle {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-80px); }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            position: relative;
            z-index: 2;
        }
        
        h1 {
            text-align: center;
            margin: 20px 0;
            font-size: 2.2rem;
            font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #ff00ff, #ffff00, #00ff88);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 4s ease-in-out infinite;
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            background-color: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            position: sticky;
            top: 10px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .version {
            background: linear-gradient(45deg, #ff006e, #8338ec);
            padding: 6px 16px;
            border-radius: 25px;
            font-size: 0.8rem;
            margin-left: 15px;
            font-weight: 700;
            color: white;
            display: inline-block;
            animation: pulse 3s infinite;
        }
        
        .encoding-indicators {
            display: flex;
            gap: 12px;
            margin-left: 15px;
            margin-top: 10px;
        }
        
        .encoding-indicator {
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.75rem;
            font-weight: 600;
            display: none;
            animation: neonPulse 2s infinite;
        }
        
        .aaencode-indicator {
            background: linear-gradient(45deg, #ff9500, #ffb347);
            color: #000;
        }
        
        .eval-indicator {
            background: linear-gradient(45deg, #ff073a, #c3073f);
            color: #fff;
        }
        
        .encoding-indicator.show {
            display: inline-block;
        }
        
        @keyframes neonPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .features-banner {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: #000;
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            animation: bannerGlow 4s ease-in-out infinite;
        }
        
        @keyframes bannerGlow {
            0%, 100% { box-shadow: 0 8px 32px rgba(255, 107, 53, 0.4); }
            50% { box-shadow: 0 12px 40px rgba(255, 107, 53, 0.6); }
        }
        
        .section {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 25px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .section:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            border-color: rgba(0, 212, 255, 0.3);
        }
        
        .section-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(45deg, #00d4ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }
        
        input, textarea, select {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            background: rgba(0,0,0,0.6);
            color: #ffffff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.3s ease;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #00d4ff;
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
        }
        
        input::placeholder, textarea::placeholder {
            color: rgba(255,255,255,0.5);
        }
        
        textarea {
            height: 200px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            resize: vertical;
            line-height: 1.6;
            border: 2px solid rgba(255,255,255,0.2) !important;
            background: rgba(0,0,0,0.6) !important;
            color: #ffffff !important;
        }
        
        textarea:focus {
            outline: none !important;
            border-color: #00d4ff !important;
            background: rgba(0,0,0,0.8) !important;
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2) !important;
        }
        
        .file-upload {
            border: 3px dashed rgba(0, 212, 255, 0.4);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            background: rgba(0, 212, 255, 0.05);
        }
        
        .file-upload:hover, .file-upload.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            transform: translateY(-3px);
        }
        
        .file-upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #00d4ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .detection-panel {
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .detection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        
        .detection-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .detection-item:hover {
            transform: translateY(-2px);
        }
        
        .detection-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .detection-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .file-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }
        
        .file-option {
            padding: 16px;
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .file-option:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }
        
        .file-option.aaencode {
            background: rgba(255,149,0,0.2);
            border-color: rgba(255,149,0,0.4);
        }
        
        .file-option.eval {
            background: rgba(255,7,58,0.2);
            border-color: rgba(255,7,58,0.4);
        }
        
        .buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin: 25px 0;
            position: sticky;
            bottom: 15px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        
        button {
            padding: 16px;
            border: none;
            border-radius: 15px;
            font-weight: 700;
            cursor: pointer;
            font-size: 0.8rem;
            color: #fff;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            font-family: inherit;
        }
        
        .btn-blue { 
            background: linear-gradient(45deg, #0066ff, #004ccc);
        }
        .btn-green { 
            background: linear-gradient(45deg, #00ff88, #00cc6a);
        }
        .btn-yellow { 
            background: linear-gradient(45deg, #ffaa00, #cc8800);
        }
        .btn-purple { 
            background: linear-gradient(45deg, #aa00ff, #8800cc);
        }
        .btn-red { 
            background: linear-gradient(45deg, #ff0044, #cc0036);
        }
        
        button:hover {
            transform: translateY(-3px) scale(1.05);
        }
        
        .btn-icon {
            font-size: 1.4rem;
        }
        
        .btn-text {
            font-size: 0.7rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88, #ffaa00);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .output {
            background: #1a1a1a;
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            min-height: 200px;
            max-height: 400px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #e0e6ed;
        }
        
        .logs {
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
        }
        
        .log-success { color: #00ff88; }
        .log-error { color: #ff0044; }
        .log-warning { color: #ffaa00; }
        .log-info { color: #00d4ff; }
        
        .toast {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px 25px;
            border-radius: 15px;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 212, 255, 0.3);
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .note {
            background: rgba(0, 212, 255, 0.1);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 16px;
            font-size: 0.85rem;
            line-height: 1.6;
            margin-top: 15px;
        }
        
        .hidden {
            display: none !important;
        }
        
        /* ÊªöÂä®Êù° */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00d4ff, #ff00ff);
            border-radius: 4px;
        }
        
        /* ÁßªÂä®Á´ØÈÄÇÈÖç */
        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }
            
            h1 {
                font-size: 1.8rem;
                padding: 15px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .buttons {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                margin: 0;
                border-radius: 0;
                border-top: 2px solid rgba(0, 212, 255, 0.3);
            }
            
            body {
                padding-bottom: 100px;
            }
            
            .section {
                padding: 20px;
                margin: 15px 0;
            }
            
            .detection-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
            
            .file-options {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            ‚ö° TECH DECODER ‚ö°
            <span class="version">v4.0</span>
            <div class="encoding-indicators">
                <div class="encoding-indicator aaencode-indicator">AAEncode</div>
                <div class="encoding-indicator eval-indicator">Eval Detected</div>
            </div>
        </h1>
        
        <div class="features-banner">
            üöÄ Advanced Code Analysis ‚Ä¢ Real-time Decoding ‚Ä¢ Multi-format Support ‚Ä¢ AI-Powered Detection üöÄ
        </div>
        
        <div class="section">
            <div class="section-title">
                üîç INPUT ANALYZER
            </div>
            <div class="form-row">
                <div>
                    <label for="input">Code Input</label>
                    <textarea id="input" placeholder="Paste your encoded code here..."></textarea>
                </div>
                <div>
                    <label for="method">Decode Method</label>
                    <select id="method">
                        <option value="auto">ü§ñ Auto Detect</option>
                        <option value="aaencode">üìä AAEncode</option>
                        <option value="eval">‚ö° Eval</option>
                        <option value="unicode">üî§ Unicode</option>
                        <option value="base64">üîê Base64</option>
                    </select>
                </div>
            </div>
            
            <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                <div class="file-upload-icon">üìÅ</div>
                <div>Click to upload file or drag & drop</div>
                <input type="file" id="fileInput" style="display:none" accept=".js,.txt,.html">
            </div>
            
            <div class="detection-panel">
                <div class="section-title">üéØ Detection Results</div>
                <div class="detection-grid">
                    <div class="detection-item">
                        <div class="detection-value">98%</div>
                        <div class="detection-label">Confidence</div>
                    </div>
                    <div class="detection-item">
                        <div class="detection-value">AAEncode</div>
                        <div class="detection-label">Method</div>
                    </div>
                    <div class="detection-item">
                        <div class="detection-value">2.5KB</div>
                        <div class="detection-label">Size</div>
                    </div>
                    <div class="detection-item">
                        <div class="detection-value">Safe</div>
                        <div class="detection-label">Status</div>
                    </div>
                </div>
            </div>
            
            <div class="file-options">
                <div class="file-option aaencode">
                    <div>üî• AAEncode</div>
                    <div style="font-size: 0.7rem; opacity: 0.8;">Advanced</div>
                </div>
                <div class="file-option eval">
                    <div>‚ö° Eval Decode</div>
                    <div style="font-size: 0.7rem; opacity: 0.8;">Dynamic</div>
                </div>
                <div class="file-option">
                    <div>üî§ Unicode</div>
                    <div style="font-size: 0.7rem; opacity: 0.8;">Standard</div>
                </div>
                <div class="file-option">
                    <div>üîê Base64</div>
                    <div style="font-size: 0.7rem; opacity: 0.8;">Basic</div>
                </div>
            </div>
            
            <div class="note">
                üí° <strong>Pro Tip:</strong> Use auto-detect for best results. The AI will analyze patterns and choose the optimal decoding method.
            </div>
        </div>
        
        <div class="buttons">
            <button class="btn-blue" onclick="decode()">
                <div class="btn-icon">üöÄ</div>
                <div class="btn-text">DECODE</div>
            </button>
            <button class="btn-green" onclick="beautify()">
                <div class="btn-icon">‚ú®</div>
                <div class="btn-text">BEAUTIFY</div>
            </button>
            <button class="btn-yellow" onclick="analyze()">
                <div class="btn-icon">üîç</div>
                <div class="btn-text">ANALYZE</div>
            </button>
            <button class="btn-purple" onclick="copy()">
                <div class="btn-icon">üìã</div>
                <div class="btn-text">COPY</div>
            </button>
            <button class="btn-red" onclick="clear()">
                <div class="btn-icon">üóëÔ∏è</div>
                <div class="btn-text">CLEAR</div>
            </button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div class="section">
            <div class="section-title">
                üìä OUTPUT TERMINAL
            </div>
            <div class="output" id="output">// Decoded output will appear here...
// Ready for analysis ‚ö°</div>
        </div>
        
        <div class="section">
            <div class="section-title">
                üìù SYSTEM LOGS
            </div>
            <div class="logs" id="logs">
                <div class="log-info">[SYSTEM] Tech Decoder v4.0 initialized ‚ö°</div>
                <div class="log-success">[STATUS] All systems operational üü¢</div>
                <div class="log-info">[READY] Waiting for input...</div>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast">
        Operation completed successfully! ‚ú®
    </div>
    
    <script>
        // ÂÖ®Â±ÄÂèòÈáè
        let isProcessing = false;
        
        // Á≠âÂæÖDOMÂä†ËΩΩÂÆåÊàê
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            initializeApp();
        });
        
        function initializeApp() {
            try {
                console.log('Initializing app...');
                
                // Ê£ÄÊü•ÂÖ≥ÈîÆÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
                const input = document.getElementById('input');
                const output = document.getElementById('output');
                const logs = document.getElementById('logs');
                
                console.log('Elements check:');
                console.log('- Input:', input ? 'found' : 'missing');
                console.log('- Output:', output ? 'found' : 'missing');
                console.log('- Logs:', logs ? 'found' : 'missing');
                
                if (!input) {
                    console.error('Critical: Input element missing!');
                    return;
                }
                
                // Âº∫Âà∂ËÆæÁΩÆËæìÂÖ•Ê°ÜÂ±ûÊÄß
                input.style.background = 'rgba(0,0,0,0.6)';
                input.style.border = '2px solid rgba(255,255,255,0.2)';
                input.style.color = '#ffffff';
                input.style.padding = '15px';
                input.disabled = false;
                input.readOnly = false;
                
                // ÊµãËØïËæìÂÖ•Ê°Ü
                input.value = '';
                input.placeholder = 'Ready! You can type here now...';
                
                console.log('Input box configured');
                
                // ÂàùÂßãÂåñÊâÄÊúâ‰∫ã‰ª∂ÁõëÂê¨Âô®
                setupEventListeners();
                
                // Ê∑ªÂä†ÂàùÂßãÊó•Âøó
                addLog('success', '[INIT] Tech Decoder v4.0 initialized ‚ö°');
                addLog('info', '[SHORTCUTS] Ctrl+Enter: Decode | Ctrl+B: Beautify | Ctrl+R: Analyze');
                addLog('success', '[READY] All systems operational üü¢');
                addLog('info', '[TEST] Try typing in the input box...');
                
                console.log('App initialized successfully');
                
                // È¢ùÂ§ñÁöÑËæìÂÖ•Ê°ÜÊµãËØï
                setTimeout(() => {
                    if (input) {
                        input.focus();
                        console.log('Input box focused for testing');
                        addLog('info', '[TEST] Input box focus test completed');
                    }
                }, 2000);
                
            } catch (error) {
                console.error('Initialization error:', error);
                alert('Initialization failed: ' + error.message);
            }
        }
        
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            // ÊåâÈíÆ‰∫ã‰ª∂ - Êõ¥Áõ¥Êé•ÁöÑÊñπÂºè
            const decodeBtn = document.querySelector('.btn-blue');
            const beautifyBtn = document.querySelector('.btn-green');
            const analyzeBtn = document.querySelector('.btn-yellow');
            const copyBtn = document.querySelector('.btn-purple');
            const clearBtn = document.querySelector('.btn-red');
            
            if (decodeBtn) {
                decodeBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('Decode button clicked');
                    decode();
                };
            }
            
            if (beautifyBtn) {
                beautifyBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('Beautify button clicked');
                    beautify();
                };
            }
            
            if (analyzeBtn) {
                analyzeBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('Analyze button clicked');
                    analyze();
                };
            }
            
            if (copyBtn) {
                copyBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('Copy button clicked');
                    copy();
                };
            }
            
            if (clearBtn) {
                clearBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('Clear button clicked');
                    clear();
                };
            }
            
            // ËæìÂÖ•Ê°Ü‰∫ã‰ª∂ - Êõ¥Áõ¥Êé•ÁöÑÁªëÂÆö
            const inputElement = document.getElementById('input');
            if (inputElement) {
                console.log('Input element found, binding events...');
                
                inputElement.oninput = function(e) {
                    console.log('Input changed:', e.target.value.length, 'characters');
                    handleInputChange(e.target.value);
                };
                
                inputElement.onfocus = function() {
                    console.log('Input focused');
                    addLog('info', '[INPUT] Text area focused');
                };
                
                inputElement.onblur = function() {
                    console.log('Input blurred');
                };
                
                // ÊµãËØïËæìÂÖ•Ê°ÜÊòØÂê¶ÂèØÁî®
                setTimeout(() => {
                    inputElement.placeholder = 'Input box is ready! Type here...';
                    console.log('Input box placeholder updated');
                }, 1000);
            } else {
                console.error('Input element not found!');
            }
            
            // Êñá‰ª∂‰∏ä‰º†‰∫ã‰ª∂
            setupFileUpload();
            
            // Êñá‰ª∂ÈÄâÈ°π‰∫ã‰ª∂
            setupFileOptions();
            
            // ÊñπÊ≥ïÈÄâÊã©‰∫ã‰ª∂
            const methodSelect = document.getElementById('method');
            if (methodSelect) {
                methodSelect.onchange = function(e) {
                    console.log('Method changed to:', e.target.value);
                    handleMethodChange(e.target.value);
                };
            }
            
            // ÈîÆÁõòÂø´Êç∑ÈîÆ
            document.onkeydown = function(e) {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key.toLowerCase()) {
                        case 'enter':
                            e.preventDefault();
                            decode();
                            break;
                        case 'b':
                            e.preventDefault();
                            beautify();
                            break;
                        case 'r':
                            e.preventDefault();
                            analyze();
                            break;
                    }
                }
            };
            
            // ËæìÂá∫Âå∫ÂüüÂèåÂáªÈÄâÊã©
            const outputElement = document.getElementById('output');
            if (outputElement) {
                outputElement.ondblclick = function() {
                    selectAllOutput();
                };
            }
            
            console.log('Event listeners setup completed');
        }
        
        function handleButtonClick(action) {
            if (isProcessing) {
                showToast('Please wait for current operation to complete! ‚è≥');
                return;
            }
            
            console.log('Handling action:', action);
            addLog('info', `[ACTION] ${action.toUpperCase()} requested`);
            
            switch(action) {
                case 'decode':
                    decode();
                    break;
                case 'beautify':
                    beautify();
                    break;
                case 'analyze':
                    analyze();
                    break;
                case 'copy':
                    copy();
                    break;
                case 'clear':
                    clear();
                    break;
                default:
                    addLog('warning', `[ACTION] Unknown action: ${action}`);
            }
        }
        
        function decode() {
            const input = document.getElementById('input').value;
            if (!input.trim()) {
                showToast('Please enter some code to decode! üìù');
                addLog('warning', '[DECODE] No input provided');
                return;
            }
            
            isProcessing = true;
            showProgress();
            addLog('info', '[DECODE] Starting decode process...');
            
            setTimeout(() => {
                try {
                    const output = document.getElementById('output');
                    const method = document.getElementById('method').value;
                    
                    let result = '';
                    
                    // ÁÆÄÂçïÁöÑËß£Á†ÅÈÄªËæë
                    switch(method) {
                        case 'base64':
                            try {
                                result = '// Base64 Decoded:\n' + atob(input);
                            } catch(e) {
                                result = '// Base64 decode failed: Invalid input\n' + input;
                            }
                            break;
                        case 'unicode':
                            result = '// Unicode processed:\n' + input.replace(/\\u[\dA-F]{4}/gi, 
                                match => String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16)));
                            break;
                        case 'eval':
                            result = '// Eval code detected (execution blocked for security):\n' + input;
                            break;
                        case 'aaencode':
                            result = '// AAEncode detected:\n' + input + '\n\n// Manual decode required';
                            break;
                        default:
                            result = '// Auto-detected format:\n' + input + '\n\n// Processing completed ‚úÖ';
                    }
                    
                    output.textContent = result;
                    addLog('success', '[DECODE] Process completed successfully!');
                    showToast('Decode completed! ‚ö°');
                } catch(error) {
                    addLog('error', '[DECODE] Error: ' + error.message);
                    showToast('Decode failed! Check logs for details.');
                } finally {
                    isProcessing = false;
                    hideProgress();
                }
            }, 1500);
        }
        
        function beautify() {
            const input = document.getElementById('input').value;
            if (!input.trim()) {
                showToast('Please enter some code to beautify! ‚ú®');
                addLog('warning', '[BEAUTIFY] No input provided');
                return;
            }
            
            isProcessing = true;
            showProgress();
            addLog('info', '[BEAUTIFY] Formatting code...');
            
            setTimeout(() => {
                try {
                    const output = document.getElementById('output');
                    // ÁÆÄÂçïÁöÑÁæéÂåñÈÄªËæë
                    let beautified = input
                        .replace(/;/g, ';\n')
                        .replace(/\{/g, '{\n  ')
                        .replace(/\}/g, '\n}')
                        .replace(/,/g, ',\n  ');
                    
                    output.textContent = '// Code beautified:\n\n' + beautified + '\n\n// Formatting completed ‚ú®';
                    addLog('success', '[BEAUTIFY] Code formatted successfully!');
                    showToast('Code beautified! ‚ú®');
                } catch(error) {
                    addLog('error', '[BEAUTIFY] Error: ' + error.message);
                    showToast('Beautify failed! Check logs for details.');
                } finally {
                    isProcessing = false;
                    hideProgress();
                }
            }, 1000);
        }
        
        function analyze() {
            isProcessing = true;
            showProgress();
            addLog('info', '[ANALYZE] Running security analysis...');
            
            setTimeout(() => {
                try {
                    const input = document.getElementById('input').value;
                    const output = document.getElementById('output');
                    
                    let analysis = '// Security Analysis Report:\n\n';
                    
                    // ÂÆâÂÖ®Ê£ÄÊü•
                    const risks = [];
                    if (input.includes('eval(')) risks.push('- Eval function detected');
                    if (input.includes('document.write')) risks.push('- Document.write detected');
                    if (input.includes('innerHTML')) risks.push('- innerHTML usage detected');
                    if (input.match(/http[s]?:\/\//)) risks.push('- External URLs detected');
                    
                    if (risks.length > 0) {
                        analysis += 'POTENTIAL RISKS:\n' + risks.join('\n') + '\n\n';
                        addLog('warning', '[ANALYZE] Security risks detected');
                    } else {
                        analysis += 'STATUS: No obvious security risks detected ‚úÖ\n\n';
                    }
                    
                    analysis += `STATISTICS:\n`;
                    analysis += `- Characters: ${input.length}\n`;
                    analysis += `- Lines: ${input.split('\n').length}\n`;
                    analysis += `- Words: ${input.trim() ? input.trim().split(/\s+/).length : 0}\n\n`;
                    analysis += '// Analysis completed üîç';
                    
                    output.textContent = analysis;
                    addLog('success', '[ANALYZE] Analysis complete!');
                    showToast('Analysis completed! üîç');
                } catch(error) {
                    addLog('error', '[ANALYZE] Error: ' + error.message);
                    showToast('Analysis failed! Check logs for details.');
                } finally {
                    isProcessing = false;
                    hideProgress();
                }
            }, 2000);
        }
        
        function copy() {
            try {
                const output = document.getElementById('output');
                const text = output.textContent;
                
                if (!text || text.trim() === '') {
                    showToast('Nothing to copy! üìù');
                    addLog('warning', '[COPY] No content to copy');
                    return;
                }
                
                // ‰ΩøÁî®Áé∞‰ª£API
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(text).then(() => {
                        addLog('success', '[COPY] Content copied to clipboard!');
                        showToast('Copied to clipboard! üìã');
                    }).catch(() => {
                        fallbackCopy(text);
                    });
                } else {
                    fallbackCopy(text);
                }
            } catch(error) {
                addLog('error', '[COPY] Error: ' + error.message);
                showToast('Copy failed! Please try again.');
            }
        }
        
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
                document.execCommand('copy');
                addLog('success', '[COPY] Content copied to clipboard!');
                showToast('Copied to clipboard! üìã');
            } catch(err) {
                addLog('error', '[COPY] Fallback copy failed');
                showToast('Copy failed! Please manually select and copy.');
            }
            
            document.body.removeChild(textArea);
        }
        
        function clear() {
            try {
                document.getElementById('input').value = '';
                document.getElementById('output').textContent = '// Output cleared\n// Ready for new input ‚ö°';
                
                // ÈáçÁΩÆÊ£ÄÊµãÁªìÊûú
                const detectionItems = document.querySelectorAll('.detection-item');
                detectionItems[0].querySelector('.detection-value').textContent = '0%';
                detectionItems[1].querySelector('.detection-value').textContent = 'Unknown';
                detectionItems[2].querySelector('.detection-value').textContent = '0B';
                detectionItems[3].querySelector('.detection-value').textContent = 'Ready';
                
                // ÈöêËóèÊåáÁ§∫Âô®
                document.querySelectorAll('.encoding-indicator').forEach(indicator => {
                    indicator.classList.remove('show');
                });
                
                addLog('info', '[CLEAR] Interface cleared');
                showToast('Interface cleared! üóëÔ∏è');
            } catch(error) {
                addLog('error', '[CLEAR] Error: ' + error.message);
            }
        }
        
        function showProgress() {
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = '100%';
            }
        }
        
        function hideProgress() {
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                setTimeout(() => {
                    progressFill.style.width = '0%';
                }, 300);
            }
        }
        
        function addLog(type, message) {
            try {
                const logs = document.getElementById('logs');
                if (!logs) return;
                
                const logElement = document.createElement('div');
                logElement.className = `log-${type}`;
                const timestamp = new Date().toLocaleTimeString();
                logElement.textContent = `[${timestamp}] ${message}`;
                logs.appendChild(logElement);
                logs.scrollTop = logs.scrollHeight;
                
                // ÈôêÂà∂Êó•ÂøóÊï∞Èáè
                if (logs.children.length > 50) {
                    logs.removeChild(logs.firstChild);
                }
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            } catch(error) {
                console.error('Log error:', error);
            }
        }
        
        function showToast(message) {
            try {
                const toast = document.getElementById('toast');
                if (!toast) return;
                
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
                
                console.log('Toast:', message);
            } catch(error) {
                console.error('Toast error:', error);
            }
        }
        
        function handleInputChange(value) {
            try {
                updateDetectionResults(value);
                updateEncodingIndicators(value);
            } catch(error) {
                console.error('Input change error:', error);
            }
        }
        
        function updateDetectionResults(code) {
            try {
                const detectionItems = document.querySelectorAll('.detection-item');
                if (detectionItems.length < 4) return;
                
                if (code.length > 0) {
                    const confidence = Math.min(95, 60 + (code.length / 100) * 30);
                    const size = formatBytes(new Blob([code]).size);
                    
                    let method = 'Text';
                    let status = 'Safe';
                    
                    if (code.includes('eval(') || code.includes('Function(')) {
                        method = 'Eval';
                        status = 'Warning';
                    } else if (code.match(/[^\x00-\x7F]/)) {
                        method = 'Unicode';
                    } else if (code.match(/^[A-Za-z0-9+/]*={0,2}$/)) {
                        method = 'Base64';
                    } else if (code.includes('ÔæüœâÔæüÔæâ') || code.includes('(Ôæü–îÔæü)')) {
                        method = 'AAEncode';
                        status = 'Encoded';
                    }
                    
                    detectionItems[0].querySelector('.detection-value').textContent = Math.round(confidence) + '%';
                    detectionItems[1].querySelector('.detection-value').textContent = method;
                    detectionItems[2].querySelector('.detection-value').textContent = size;
                    detectionItems[3].querySelector('.detection-value').textContent = status;
                    
                    const statusElement = detectionItems[3].querySelector('.detection-value');
                    statusElement.style.color = status === 'Safe' ? '#00ff88' : (status === 'Warning' ? '#ffaa00' : '#00d4ff');
                }
            } catch(error) {
                console.error('Detection update error:', error);
            }
        }
        
        function updateEncodingIndicators(code) {
            try {
                const aaencodeIndicator = document.querySelector('.aaencode-indicator');
                const evalIndicator = document.querySelector('.eval-indicator');
                
                if (aaencodeIndicator) {
                    if (code.includes('ÔæüœâÔæüÔæâ') || code.includes('(Ôæü–îÔæü)')) {
                        aaencodeIndicator.classList.add('show');
                    } else {
                        aaencodeIndicator.classList.remove('show');
                    }
                }
                
                if (evalIndicator) {
                    if (code.includes('eval(') || code.includes('Function(')) {
                        evalIndicator.classList.add('show');
                    } else {
                        evalIndicator.classList.remove('show');
                    }
                }
            } catch(error) {
                console.error('Indicator update error:', error);
            }
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + sizes[i];
        }
        
        function setupFileUpload() {
            try {
                const fileUpload = document.querySelector('.file-upload');
                const fileInput = document.getElementById('fileInput');
                
                if (!fileUpload || !fileInput) return;
                
                fileUpload.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    fileUpload.classList.add('dragover');
                });
                
                fileUpload.addEventListener('dragleave', function() {
                    fileUpload.classList.remove('dragover');
                });
                
                fileUpload.addEventListener('drop', function(e) {
                    e.preventDefault();
                    fileUpload.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFile(files[0]);
                    }
                });
                
                fileInput.addEventListener('change', function(e) {
                    if (e.target.files.length > 0) {
                        handleFile(e.target.files[0]);
                    }
                });
            } catch(error) {
                console.error('File upload setup error:', error);
            }
        }
        
        function setupFileOptions() {
            try {
                const fileOptions = document.querySelectorAll('.file-option');
                fileOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        const text = option.textContent.toLowerCase();
                        addLog('info', `[METHOD] Selected: ${text}`);
                        
                        const select = document.getElementById('method');
                        if (select) {
                            if (text.includes('aaencode')) {
                                select.value = 'aaencode';
                            } else if (text.includes('eval')) {
                                select.value = 'eval';
                            } else if (text.includes('unicode')) {
                                select.value = 'unicode';
                            } else if (text.includes('base64')) {
                                select.value = 'base64';
                            }
                        }
                        
                        showToast(`Method selected: ${text} üéØ`);
                    });
                });
            } catch(error) {
                console.error('File options setup error:', error);
            }
        }
        
        function handleFile(file) {
            try {
                addLog('info', `[FILE] Loading: ${file.name}`);
                showToast(`File loaded: ${file.name} üìÅ`);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const input = document.getElementById('input');
                    if (input) {
                        input.value = e.target.result;
                        handleInputChange(e.target.result);
                        addLog('success', '[FILE] Content loaded successfully');
                    }
                };
                reader.onerror = function() {
                    addLog('error', '[FILE] Failed to read file');
                    showToast('Failed to read file! üìÅ');
                };
                reader.readAsText(file);
            } catch(error) {
                addLog('error', '[FILE] Error: ' + error.message);
                showToast('File handling error!');
            }
        }
        
        function handleMethodChange(method) {
            try {
                addLog('info', `[METHOD] Changed to: ${method}`);
                
                // È´ò‰∫ÆÂØπÂ∫îÁöÑÈÄâÈ°π
                const fileOptions = document.querySelectorAll('.file-option');
                fileOptions.forEach(option => {
                    option.style.transform = 'scale(1)';
                    option.style.borderColor = 'rgba(255,255,255,0.1)';
                });
                
                const targetOption = document.querySelector(`.file-option.${method}`);
                if (targetOption) {
                    targetOption.style.transform = 'scale(1.05)';
                    targetOption.style.borderColor = '#00d4ff';
                }
            } catch(error) {
                console.error('Method change error:', error);
            }
        }
        
        function selectAllOutput() {
            try {
                const output = document.getElementById('output');
                if (!output) return;
                
                const range = document.createRange();
                range.selectNodeContents(output);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                showToast('Output text selected! üìù');
            } catch(error) {
                console.error('Select all error:', error);
            }
        }
        
        // ÈîôËØØÂ§ÑÁêÜ
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            addLog('error', `[ERROR] ${e.message}`);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
            addLog('error', `[PROMISE] ${e.reason}`);
        });
        
        // Ë∞ÉËØï‰ø°ÊÅØ
        console.log('Script loaded successfully');
</style>
</head>
<body>
    <div class="container">
        <h1>
            ÁæäÊØõÂä©Êâã 
            <span class="version">v6.0</span>
            <div class="encoding-indicators">
                <span id="aaencodeIndicator" class="encoding-indicator aaencode-indicator">AAEncodeÂ∑≤Ê£ÄÊµã</span>
                <span id="evalIndicator" class="encoding-indicator eval-indicator">EvalÂ∑≤Ê£ÄÊµã</span>
            </div>
        </h1>
        
        <div class="features-banner">
            üéØ v6.0Â¢ûÂº∫ÁâàÔºö‰∏ì‰∏öAADecode+EvalËß£ÂåÖÊèí‰ª∂ | ÊîØÊåÅÂ§¥ÈÉ®Ê≥®Èáä‰øùÁïô | Êô∫ËÉΩÂ§öÈáçÊ£ÄÊµã | ‰∏ÄÈîÆÊú¨Âú∞Ëß£ÂØÜ
        </div>
        
        <!-- GitHub ÈÖçÁΩÆ -->
        <div class="section">
            <div class="section-title">‚öôÔ∏è GitHub ÈÖçÁΩÆÔºàÂèØÈÄâÔºâ</div>
            <div class="form-row">
                <div>
                    <label>GitHub Token</label>
                    <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxx">
                </div>
                <div>
                    <label>‰ªìÂ∫ìÂú∞ÂùÄ</label>
                    <input type="text" id="repo" placeholder="username/repo">
                </div>
            </div>
            <div class="note">
                <strong>üí° ËØ¥ÊòéÔºö</strong>AAEncodeÂíåEval‰ª£Á†ÅÂèØÁõ¥Êé•Êú¨Âú∞Ëß£ÂØÜÔºåÊó†ÈúÄGitHubÈÖçÁΩÆ„ÄÇGitHubÈÖçÁΩÆ‰ªÖÁî®‰∫éÂÖ∂‰ªñÂ§çÊùÇÊ∑∑Ê∑Ü‰ª£Á†ÅÁöÑ‰∫ëÁ´ØËß£ÂØÜ„ÄÇ
            </div>
        </div>
        
        <!-- Êñá‰ª∂ËæìÂÖ•Âå∫Âüü - 5‰∏™Âõ∫ÂÆöÊåâÈíÆ -->
<div class="card">
    <h3>üìÅ Êñá‰ª∂ËæìÂÖ•</h3>
    
    <div class="file-upload" onclick="document.getElementById('fileInput').click()" 
         ondragover="handleDragOver(event)" 
         ondragleave="handleDragLeave(event)" 
         ondrop="handleDrop(event)">
        <div class="file-upload-icon">üìÑ</div>
        <div class="file-upload-text">ÁÇπÂáªÈÄâÊã©Êñá‰ª∂ÊàñÊãñÊãΩÊñá‰ª∂Âà∞Ê≠§Â§Ñ</div>
        <div class="file-upload-hint">ÊîØÊåÅ .js .txt .json Á≠âÊñáÊú¨Êñá‰ª∂</div>
    </div>
    
    <input type="file" id="fileInput" accept=".js,.txt,.json">
    
    <!-- Âõ∫ÂÆö5ÊåâÈíÆÂ∏ÉÂ±Ä -->
    <div style="display: flex; gap: 6px; margin-top: 20px;">
        <button onclick="document.getElementById('fileInput').click()" 
                style="flex: 1; min-width: 0; background: linear-gradient(135deg, #2196f3, #21cbf3); color: white; padding: 12px 4px; border-radius: 12px; border: none; font-size: 11px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 60px; text-align: center;">
            üìÅ<br><span style="font-size: 10px;">ÈÄâÊã©Êñá‰ª∂</span>
        </button>
        <button onclick="showRemoteUrlDialog()" 
        style="flex: 1; min-width: 0; background: linear-gradient(135deg, #f44336, #e57373); color: white; padding: 12px 4px; border-radius: 12px; border: none; font-size: 11px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 60px; text-align: center;">
            üåê<br><span style="font-size: 10px;">ËøúÁ®ãÂä†ËΩΩ</span>
        </button>
        <button onclick="pasteFromClipboard()" 
                style="flex: 1; min-width: 0; background: linear-gradient(135deg, #4caf50, #66bb6a); color: white; padding: 12px 4px; border-radius: 12px; border: none; font-size: 11px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 60px; text-align: center;">
            üìã<br><span style="font-size: 10px;">Á≤òË¥¥Êùø</span>
        </button>
        <button onclick="cleanInput()" 
                style="flex: 1; min-width: 0; background: linear-gradient(135deg, #ff9800, #ffb74d); color: white; padding: 12px 4px; border-radius: 12px; border: none; font-size: 11px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 60px; text-align: center;">
            üßπ<br><span style="font-size: 10px;">Ê∏ÖÁêÜ‰ª£Á†Å</span>
        </button>
        <button onclick="clearInput()" 
                style="flex: 1; min-width: 0; background: linear-gradient(135deg, #9c27b0, #ba68c8); color: white; padding: 12px 4px; border-radius: 12px; border: none; font-size: 11px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 2px; min-height: 60px; text-align: center;">
            üóë<br><span style="font-size: 10px;">clearInput</span>
        </button>
    </div>
</div>
        
        <!-- Ê£ÄÊµãÈù¢Êùø -->
        <div id="detectionPanel" class="detection-panel" style="display: none;">
            <div class="section-title">üîç ÁºñÁ†ÅÊ†ºÂºèÊ£ÄÊµãÁªìÊûú</div>
            <div class="detection-grid">
                <div class="detection-item">
                    <div id="detectionType" class="detection-value">Êú™Ê£ÄÊµã</div>
                    <div class="detection-label">ÁºñÁ†ÅÁ±ªÂûã</div>
                </div>
                <div class="detection-item">
                    <div id="detectionConfidence" class="detection-value">0%</div>
                    <div class="detection-label">ÁΩÆ‰ø°Â∫¶</div>
                </div>
                <div class="detection-item">
                    <div id="detectionFeatures" class="detection-value">0</div>
                    <div class="detection-label">ÁâπÂæÅÂåπÈÖç</div>
                </div>
                <div class="detection-item">
                    <div id="detectionDetails" class="detection-value">-</div>
                    <div class="detection-label">ËØ¶ÁªÜ‰ø°ÊÅØ</div>
                </div>
            </div>
        </div>
        
<!-- ‰ª£Á†ÅËæìÂÖ•Âå∫Âüü - ÂéªÊéâÂ§ö‰ΩôÊåâÈíÆ -->
<div class="card">
    <h3>‚úèÔ∏è ‰ª£Á†ÅËæìÂÖ•</h3>
    <div class="input-section">
        <textarea id="input" class="code-input" placeholder="ËØ∑Á≤òË¥¥ÈúÄË¶ÅËß£ÂØÜÁöÑJavaScript‰ª£Á†Å..." rows="10"></textarea>
    </div>
</div>
        
        <!-- ËøõÂ∫¶Êù° -->
        <div class="progress-bar">
            <div id="progress" class="progress-fill"></div>
        </div>
        
        <!-- ËæìÂá∫ÁªìÊûú -->
        <div class="section">
            <div class="section-title">‚ú® Ëß£ÂØÜÁªìÊûú</div>
            <div id="output" class="output">// Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå...</div>
            </div>
        </div>
        
        <!-- ÊâßË°åÊó•Âøó -->
        <div class="section">
            <div class="section-title">üìã ÊâßË°åÊó•Âøó</div>
            <div id="logs" class="logs"></div>
        </div>
        
        <!-- ÊéßÂà∂ÊåâÈíÆ -->
        <div class="buttons">
            <button class="btn-blue" onclick="startDecrypt()">
                <div class="btn-icon">üîì</div>
                <div class="btn-text">ÂºÄÂßãËß£ÂØÜ</div>
            </button>
            <button class="btn-green" onclick="getResult()">
                <div class="btn-icon">üì•</div>
                <div class="btn-text">Ëé∑ÂèñÁªìÊûú</div>
            </button>
            <button class="btn-yellow" onclick="copyResult()">
                <div class="btn-icon">üìã</div>
                <div class="btn-text">Â§çÂà∂</div>
            </button>
            <button class="btn-purple" onclick="beautifyCode()">
                <div class="btn-icon">üé®</div>
                <div class="btn-text">‰ª£Á†ÅÁæéÂåñ</div>
            </button>
            <button class="btn-red" onclick="clearAll()">
                <div class="btn-icon">üóë</div>
                <div class="btn-text">Ê∏ÖÈô§</div>
            </button>
        </div>
    </div>
    
    <!-- Toast -->
    <div id="toast" class="toast"></div>

    <script>
    
    // ‰∏ì‰∏öAADecodeÊèí‰ª∂
        (function() {
            const module = { exports: {} };
            
            function extractHeader(code) {
                const aaStartIndex = code.search(/ÔæüœâÔæüÔæâ\s*=|Ôæü–¥Ôæü\s*=|Ôæü–îÔæü\s*=|ÔæüŒòÔæü\s*=/);
                
                if (aaStartIndex > 0) {
                    const header = code.substring(0, aaStartIndex).trim();
                    const encodedPart = code.substring(aaStartIndex);
                    return { header, encodedPart };
                }
                
                return { header: '', encodedPart: code };
            }

            function plugin(code) {
                try {
                    const { header, encodedPart } = extractHeader(code);
                    
                    if (!(encodedPart.includes('Ôæü–îÔæü') || encodedPart.includes('(ÔæüŒòÔæü)') || 
                          encodedPart.includes('ÔæüœâÔæüÔæâ') || encodedPart.includes('Ôæü–¥Ôæü'))) {
                        return null;
                    }
                    
                    let decodePart = encodedPart;
                    decodePart = decodePart.replace(") ('_')", "");
                    decodePart = decodePart.replace("(Ôæü–îÔæü) ['_'] (", "return ");
                    
                    const x = new Function(decodePart);
                    const decodedContent = x();
                    
                    if (header) {
                        return `${header}\n\n${decodedContent}`;
                    }
                    
                    return decodedContent;
                } catch (error) {
                    console.error('AADecodeËß£Á†ÅÈîôËØØ:', error);
                    return null;
                }
            }

            module.exports = plugin;
            
            window.DecodePlugins = window.DecodePlugins || {};
            window.DecodePlugins.aadecode = {
                detect: function(code) {
                    return code.includes('ÔæüœâÔæüÔæâ') || code.includes('Ôæü–îÔæü') || 
                           code.includes('Ôæü–¥Ôæü') || code.includes('ÔæüŒòÔæü');
                },
                plugin: function(code) {
                    try {
                        console.log("Â∞ùËØïËß£ÂØÜAADecodeÁºñÁ†Å...");
                        const result = module.exports(code);
                        return result !== null ? result : code;
                    } catch (e) {
                        console.error("AADecodeÊèí‰ª∂ÈîôËØØ:", e);
                        return code;
                    }
                }
            };
            
            window.professionalAADecode = module.exports;
            console.log("‰∏ì‰∏öAADecodeÊèí‰ª∂Â∑≤Âä†ËΩΩ");
        })();

        /**
         * EvalËß£ÂåÖÂ∑•ÂÖ∑ÂåÖË£ÖÂô® - Â∞ÜEvalËß£ÂåÖÂ∑•ÂÖ∑ËΩ¨Êç¢‰∏∫ÊµèËßàÂô®ÂèØÁî®ÁâàÊú¨
         */
        // ÂàõÂª∫Ëá™ÊâßË°åÂáΩÊï∞Êù•ÈöîÁ¶ª‰ΩúÁî®Âüü
        (function() {
          // Ê®°ÊãüNode.jsÁéØÂ¢É
          const module = { exports: {} };
          const exports = module.exports;
          
          // ‰ª•‰∏ãÁ≤òË¥¥ÂéüÂßãeval-decoder.jsÊèí‰ª∂‰ª£Á†Å
          // ====== ÂºÄÂßã: ÂéüÂßãeval-decoder.js‰ª£Á†Å ======
          
          /**
           * Ëß£ÂåÖevalÂä†ÂØÜÁöÑ‰ª£Á†Å
           * @param {string} code - Ë¶ÅËß£ÂåÖÁöÑ‰ª£Á†Å
           * @returns {string|null} - Ëß£ÂåÖÂêéÁöÑ‰ª£Á†ÅÊàñnullÔºàËß£ÂåÖÂ§±Ë¥•Êó∂Ôºâ
           */
          function plugin(code) {
            try {
              // Â¶ÇÊûú‰∏çÂåÖÂê´evalÔºåÁõ¥Êé•ËøîÂõûnull
              if (!code.includes('eval(') && !code.includes('eval (')) {
                return null;
              }
              
              // ÊõøÊç¢eval‰∏∫‰∏Ä‰∏™ÊçïËé∑ÂáΩÊï∞
              let modifiedCode = code.replace(/eval\s*\(/g, '(function(x) { return x; })(');
              
              // Â∞ùËØïÊâßË°å‰øÆÊîπÂêéÁöÑ‰ª£Á†ÅËé∑ÂèñevalÁöÑÂèÇÊï∞
              try {
                // ÂàõÂª∫‰∏Ä‰∏™ÊâßË°åÁéØÂ¢É
                const env = {
                  window: {},
                  document: {},
                  navigator: { userAgent: "Mozilla/5.0" },
                  location: {}
                };
                
                // ÊâßË°å‰ª£Á†Å
                const result = Function('window', 'document', 'navigator', 'location',
                                      `return ${modifiedCode}`)(
                                      env.window, env.document, env.navigator, env.location);
                
                // Â¶ÇÊûúÁªìÊûúÊòØÂ≠óÁ¨¶‰∏≤‰∏îÂåÖÂê´evalÔºåÈÄíÂΩíËß£ÂåÖ
                if (typeof result === 'string') {
                  if (result.includes('eval(')) {
                    return plugin(result);
                  }
                  return result;
                }
                
                return String(result);
              } catch (err) {
                console.log("ÊâßË°åÊõøÊç¢evalÁöÑÊñπÊ≥ïÂ§±Ë¥•ÔºåÂ∞ùËØïÁõ¥Êé•ÊõøÊç¢ÊñπÊ≥ï");
                
                // Â∞ùËØïÁõ¥Êé•ÊõøÊç¢eval
                try {
                  modifiedCode = code.replace(/eval\s*\(/g, '(');
                  return modifiedCode;
                } catch (replaceErr) {
                  console.error("Áõ¥Êé•ÊõøÊç¢evalÊñπÊ≥ï‰πüÂ§±Ë¥•:", replaceErr);
                  return null;
                }
              }
            } catch (error) {
              console.error("EvalËß£ÂåÖÂèëÁîüÈîôËØØ:", error);
              return null;
            }
          }
          
          // ÂØºÂá∫Êèí‰ª∂Êé•Âè£
          exports.plugin = function(code) {
            return plugin(code);
          };
          
          // ====== ÁªìÊùü: ÂéüÂßãeval-decoder.js‰ª£Á†Å ======
          
          // Â∞ÜÊèí‰ª∂Ê≥®ÂÜåÂà∞ÂÖ®Â±ÄËß£ÂØÜÊèí‰ª∂Â∫ì
          window.DecodePlugins = window.DecodePlugins || {};
          window.DecodePlugins.eval = {
            detect: function(code) {
              // Ê£ÄÊµãÊòØÂê¶ÂåÖÂê´evalË∞ÉÁî®
              return code.includes('eval(') || code.includes('eval (');
            },
            plugin: function(code) {
              // ‰ΩøÁî®ÂéüÂßãÊ®°ÂùóÁöÑÂäüËÉΩ
              return module.exports.plugin(code);
            }
          };
          
          console.log("EvalËß£ÂåÖÊèí‰ª∂Â∑≤Âä†ËΩΩ");
        })();
        
        // Â∫îÁî®ÈÖçÁΩÆ
        const APP_CONFIG = {
            VERSION: '6.0',
            VERSION_NAME: 'Â¢ûÂº∫ÁâàAADecode+EvalËß£ÂØÜÂ∑•ÂÖ∑',
            UPDATE_NOTES: 'ÈõÜÊàê‰∏ì‰∏öAADecodeÂíåEvalËß£ÂåÖÊèí‰ª∂ÔºåÊîØÊåÅÂ§¥ÈÉ®Ê≥®Èáä‰øùÁïôÂíåÊô∫ËÉΩÊ£ÄÊµã'
        };
        
        window.appData = {
            token: localStorage.getItem('github_token') || '',
            repo: localStorage.getItem('repo_name') || '',
            isAAEncodeMode: false,
            isEvalMode: false,
            lastDetection: null
        };
        
        // Ê£ÄÊµãÂáΩÊï∞
        function detectAAEncode(input) {
            const aaencodeChars = /[Ôæüœâ„ÉéŒòŒî–îŒµÔΩ∞ÔΩç'‚àáÔΩÄ~‚îª‚îÅ_=3o\^c\/\*\\\"()[\]!+]/g;
            const matches = input.match(aaencodeChars) || [];
            const ratio = matches.length / input.length;
            
            const aaencodePatterns = [
                /ÔæüœâÔæüÔæâ/, /ÔæüÔΩ∞Ôæü/, /ÔæüŒòÔæü/, /Ôæü–îÔæü/, /Ôæü–¥Ôæü/,
                /o\^_\^o/, /c\^_\^o/, /\(ÔæüŒòÔæü\)/, /\['_'\]/
            ];
            
            const patternMatches = aaencodePatterns.filter(pattern => pattern.test(input)).length;
            
            const hasMinLength = input.length >= 100;
            const hasAASignature = input.includes('Ôæü–îÔæü') && input.includes('ÔæüœâÔæüÔæâ');
            
            let confidence = 0;
            if (hasAASignature) confidence += 40;
            if (patternMatches >= 3) confidence += 30;
            if (ratio > 0.3) confidence += Math.min(ratio * 50, 25);
            if (hasMinLength) confidence += 5;
            
            const isAAEncode = confidence >= 70 || (hasAASignature && patternMatches >= 2);
            
            return {
                type: 'AAEncode',
                isDetected: isAAEncode,
                confidence: Math.min(confidence, 100),
                ratio: Math.round(ratio * 100),
                patternMatches,
                hasAASignature,
                length: input.length,
                features: aaencodePatterns.filter(pattern => pattern.test(input)).map(p => p.source)
            };
        }
        
        function detectEval(input) {
            const evalPatterns = [
                /eval\s*\(/gi, 
                /eval\s+\(/gi, 
                /window\s*\[\s*['"]eval['"]\s*\]/gi,
                /this\s*\[\s*['"]eval['"]\s*\]/gi, 
                /Function\s*\(/gi,
                /setTimeout\s*\(\s*['"`]/gi,
                /setInterval\s*\(\s*['"`]/gi,
                /new\s+Function\s*\(/gi,
                /\[\s*['"]eval['"]\s*\]/gi,
                /window\[['"]eval['"]\]/gi,
                /eval\w*\s*\(/gi
            ];
            
            const evalMatches = evalPatterns.map(pattern => {
                const matches = input.match(pattern);
                return matches ? matches.length : 0;
            });
            
            const totalEvalMatches = evalMatches.reduce((sum, count) => sum + count, 0);
            const nestedEvalDepth = checkNestedEvalDepth(input);
            const hasStringEncoding = /['"]\s*\+\s*['"]/.test(input);
            const hasUnicodeEscape = /\\u[0-9a-fA-F]{4}/.test(input);
            const hasHexEncoding = /\\x[0-9a-fA-F]{2}/.test(input);
            const hasObfuscatedStrings = /['"`][A-Za-z0-9+/=]{20,}['"`]/.test(input);
            const hasPackedCode = /function\s*\(\s*p\s*,\s*a\s*,\s*c\s*,\s*k\s*,\s*e\s*,\s*d\s*\)/.test(input);
            const hasEvalString = /eval\s*\(\s*['"`]/.test(input);
            const hasBase64Like = /[A-Za-z0-9+/]{50,}=*/.test(input);
            const hasUnescape = /unescape\s*\(/gi.test(input);
            const hasAtob = /atob\s*\(/gi.test(input);
            const hasCharCodeAt = /charCodeAt\s*\(/gi.test(input);
            const hasFromCharCode = /fromCharCode\s*\(/gi.test(input);
            
            // ÁâπÊÆäevalË∞ÉÁî®Ê®°Âºè
            const specialEvalPatterns = [
                /eval\s*\(\s*function\s*\(/i,
                /eval\s*\(\s*unescape\s*\(/i,
                /eval\s*\(\s*atob\s*\(/i,
                /eval\s*\(\s*decode/i,
                /eval\s*\(\s*String\s*\./i,
                /eval\s*\(\s*[a-zA-Z_$][a-zA-Z0-9_$]*\s*\(/i
            ];
            
            const specialMatches = specialEvalPatterns.filter(pattern => pattern.test(input)).length;
            
            let confidence = 0;
            
            // Âü∫Á°ÄÊ£ÄÊµã - Â§ßÂπÖÈôç‰ΩéÈòàÂÄº
            if (totalEvalMatches >= 1) confidence += 35;
            if (totalEvalMatches >= 2) confidence += 20;
            if (totalEvalMatches >= 3) confidence += 15;
            if (totalEvalMatches >= 5) confidence += 10;
            
            // ÁâπÊÆäevalÊ®°ÂºèÊ£ÄÊµã
            if (hasEvalString) confidence += 30;
            if (specialMatches >= 1) confidence += 25;
            if (specialMatches >= 2) confidence += 15;
            
            // Packed‰ª£Á†ÅÊ£ÄÊµã
            if (hasPackedCode) confidence += 35;
            
            // ÂµåÂ•óÊ∑±Â∫¶
            if (nestedEvalDepth >= 1) confidence += 25;
            if (nestedEvalDepth >= 2) confidence += 20;
            if (nestedEvalDepth >= 3) confidence += 15;
            
            // ÁºñÁ†ÅÁâπÂæÅÊ£ÄÊµã
            if (hasStringEncoding) confidence += 12;
            if (hasUnicodeEscape) confidence += 15;
            if (hasHexEncoding) confidence += 15;
            if (hasObfuscatedStrings) confidence += 20;
            if (hasBase64Like) confidence += 12;
            if (hasUnescape) confidence += 18;
            if (hasAtob) confidence += 18;
            if (hasCharCodeAt) confidence += 10;
            if (hasFromCharCode) confidence += 10;
            
            // ÈïøÂ∫¶ÂíåÂØÜÂ∫¶Ê£ÄÊü•
            if (input.length > 1000 && totalEvalMatches >= 1) confidence += 15;
            if (input.length > 5000 && totalEvalMatches >= 1) confidence += 10;
            
            const evalDensity = totalEvalMatches / Math.max(input.length / 1000, 1);
            if (evalDensity > 0.3) confidence += 15;
            if (evalDensity > 0.5) confidence += 10;
            if (evalDensity > 1.0) confidence += 8;
            
            // ‰ª£Á†ÅÊ∑∑Ê∑ÜÁâπÂæÅ
            const obfuscationFeatures = [
                /\w{1,2}\[\w{1,2}\]\[\w{1,2}\]/.test(input), // Êï∞ÁªÑËÆøÈóÆÈìæ
                /\+\s*!!\s*\[\]/.test(input), // Â∏ÉÂ∞îËΩ¨Êç¢
                /\[\]\[['"][a-zA-Z]+['"]\]/.test(input), // Êï∞ÁªÑÂ±ûÊÄßËÆøÈóÆ
                /\(\s*!\s*\[\]\s*\+\s*\[\]\s*\)/.test(input) // ÈÄªËæëËøêÁÆó
            ];
            
            const obfuscationCount = obfuscationFeatures.filter(Boolean).length;
            if (obfuscationCount >= 1) confidence += 10;
            if (obfuscationCount >= 2) confidence += 8;
            if (obfuscationCount >= 3) confidence += 5;
            
            // Â≠óÁ¨¶‰∏≤ÊãºÊé•Ê£ÄÊµã
            const stringConcatCount = (input.match(/['"][^'"]*['"]\s*\+\s*['"][^'"]*['"]/g) || []).length;
            if (stringConcatCount >= 3) confidence += 10;
            if (stringConcatCount >= 10) confidence += 8;
            
            // ÂèòÈáèÂêçÊ∑∑Ê∑ÜÊ£ÄÊµã
            const shortVarNames = (input.match(/\b[a-zA-Z_$][a-zA-Z0-9_$]{0,2}\b/g) || []).length;
            const totalTokens = (input.match(/\b[a-zA-Z_$][a-zA-Z0-9_$]*\b/g) || []).length;
            const shortVarRatio = totalTokens > 0 ? shortVarNames / totalTokens : 0;
            
            if (shortVarRatio > 0.7 && totalTokens > 20) confidence += 8;
            
            // ÊúÄÁªàÂà§Êñ≠ - Ëøõ‰∏ÄÊ≠•Èôç‰ΩéÈòàÂÄº
            const isEval = confidence >= 25 || totalEvalMatches >= 1 || specialMatches >= 1;
            
            // ÁâπÊÆäÊÉÖÂÜµÔºöÂç≥‰ΩøÁΩÆ‰ø°Â∫¶‰∏çÂ§üÔºå‰ΩÜÊúâÊòéÁ°ÆevalË∞ÉÁî®‰πüËÆ§‰∏∫ÊòØeval
            const forceDetect = totalEvalMatches >= 1 || hasEvalString || hasPackedCode;
            
            return {
                type: 'Eval',
                isDetected: isEval || forceDetect,
                confidence: Math.min(confidence, 100),
                evalCount: totalEvalMatches,
                nestedDepth: nestedEvalDepth,
                hasStringEncoding,
                hasUnicodeEscape,
                hasHexEncoding,
                hasObfuscatedStrings,
                hasPackedCode,
                hasEvalString,
                hasBase64Like,
                hasUnescape,
                hasAtob,
                hasCharCodeAt,
                hasFromCharCode,
                specialMatches,
                obfuscationCount,
                stringConcatCount,
                shortVarRatio: Math.round(shortVarRatio * 100),
                patterns: evalMatches,
                length: input.length,
                density: Math.round(evalDensity * 100) / 100,
                forceDetect
            };
        }
        
        function checkNestedEvalDepth(code) {
            let depth = 0;
            let maxDepth = 0;
            let currentPos = 0;
            
            // Êõ¥ÂáÜÁ°ÆÁöÑÂµåÂ•óÊ£ÄÊµã
            const evalRegex = /eval\s*\(/gi;
            let match;
            
            while ((match = evalRegex.exec(code)) !== null) {
                let pos = match.index;
                let parenDepth = 0;
                let nestedEvals = 0;
                
                // ‰ªéeval‰ΩçÁΩÆÂºÄÂßãÔºåÊü•ÊâæÂØπÂ∫îÁöÑÈó≠ÂêàÊã¨Âè∑
                for (let i = pos + match[0].length; i < code.length; i++) {
                    if (code[i] === '(') {
                        parenDepth++;
                    } else if (code[i] === ')') {
                        if (parenDepth === 0) break;
                        parenDepth--;
                    } else if (code.substr(i, 4).toLowerCase() === 'eval' && parenDepth > 0) {
                        nestedEvals++;
                    }
                }
                
                maxDepth = Math.max(maxDepth, nestedEvals + 1);
            }
            
            return maxDepth;
        }
        
        function comprehensiveDetection(input) {
    // üÜï Á¨¨‰∏Ä‰ºòÂÖàÁ∫ßÔºöÊ£ÄÊµãjsjiami
    if (input.includes('jsjiami.com.v5') || input.includes('jsjiami.com.v6') || input.includes('jsjiami.com.v7')) {
        return {
            primaryType: 'jsjiami',
            primaryConfidence: 95,
            primaryResult: { 
                type: 'jsjiami', 
                confidence: 95, 
                method: 'UnicodeËΩ¨‰πâ',
                isDetected: true 
            },
            aaResult: { isDetected: false, confidence: 0 },
            evalResult: { isDetected: false, confidence: 0 },
            hasMultipleEncodings: false
        };
    }
    
    const aaResult = detectAAEncode(input);
    const evalResult = detectEval(input);
    
    let primaryType = 'Unknown';
    let primaryConfidence = 0;
    let primaryResult = null;
    
    if (aaResult.isDetected && aaResult.confidence > evalResult.confidence) {
        primaryType = 'AAEncode';
        primaryConfidence = aaResult.confidence;
        primaryResult = aaResult;
    } else if (evalResult.isDetected) {
        primaryType = 'Eval';
        primaryConfidence = evalResult.confidence;
        primaryResult = evalResult;
    }
    
    return {
        primaryType,
        primaryConfidence,
        primaryResult,
        aaResult,
        evalResult,
        hasMultipleEncodings: aaResult.isDetected && evalResult.isDetected
    };
}
        
        function decodeAAEncode(code) {
            try {
                addLog('üî§ ‰ΩøÁî®‰∏ì‰∏öAADecodeÊèí‰ª∂Ëß£ÂØÜ...', 'info');
                
                const result = window.professionalAADecode(code);
                
                if (result !== null && result !== undefined && result !== code) {
                    const resultStr = String(result);
                    addLog('‚úÖ ‰∏ì‰∏öAADecodeËß£ÂØÜÊàêÂäüÔºÅ', 'success');
                    return {
                        success: true,
                        method: '‰∏ì‰∏öAADecodeÊèí‰ª∂',
                        result: resultStr,
                        preservedHeader: result.includes('\n\n') && code.search(/ÔæüœâÔæüÔæâ|Ôæü–îÔæü/) > 0
                    };
                } else {
                    throw new Error('‰∏ì‰∏öÊèí‰ª∂ËøîÂõûÁ©∫ÁªìÊûúÊàñÊú™ÊîπÂèò');
                }
                
            } catch (error) {
                addLog('‚ùå ‰∏ì‰∏öAADecodeËß£ÂØÜÂ§±Ë¥•: ' + error.message, 'error');
                
                try {
                    addLog('üîÑ Â∞ùËØïÈÄöÁî®AADecodeÊèí‰ª∂...', 'info');
                    if (window.DecodePlugins && window.DecodePlugins.aadecode) {
                        const backupResult = window.DecodePlugins.aadecode.plugin(code);
                        if (backupResult && backupResult !== code) {
                            addLog('‚úÖ ÈÄöÁî®AADecodeËß£ÂØÜÊàêÂäüÔºÅ', 'success');
                            return {
                                success: true,
                                method: 'ÈÄöÁî®AADecodeÊèí‰ª∂',
                                result: String(backupResult),
                                warning: '‰ΩøÁî®Â§áÁî®Ëß£ÂØÜÊñπÊ°à'
                            };
                        }
                    }
                } catch (e2) {
                    addLog('‚ùå Â§áÁî®Êèí‰ª∂‰πüÂ§±Ë¥•: ' + e2.message, 'error');
                }
                
                return {
                    success: false,
                    method: 'Ëß£ÂØÜÂ§±Ë¥•',
                    result: null,
                    error: 'AAEncodeËß£ÂØÜÂ§±Ë¥•: ' + error.message
                };
            }
        }
        
        function decodeEval(code) {
            try {
                addLog('üîß ‰ΩøÁî®‰∏ì‰∏öEvalËß£ÂåÖÊèí‰ª∂Ëß£ÂØÜ...', 'info');
                
                const result = window.DecodePlugins.eval.plugin(code);
                
                if (result !== null && result !== undefined && result !== code) {
                    const resultStr = String(result);
                    addLog('‚úÖ ‰∏ì‰∏öEvalËß£ÂåÖÊàêÂäüÔºÅ', 'success');
                    
                    const detection = comprehensiveDetection(resultStr);
                    if (detection.primaryType !== 'Unknown' && detection.primaryConfidence > 60) {
                        addLog('üîÑ Ê£ÄÊµãÂà∞ÂµåÂ•óÁºñÁ†ÅÔºåÂºÄÂßãÈÄíÂΩíËß£ÂØÜ...', 'info');
                        const recursiveResult = performDecryption(resultStr);
                        if (recursiveResult.success) {
                            return {
                                success: true,
                                method: 'EvalËß£ÂåÖ+ÈÄíÂΩíËß£ÂØÜ',
                                result: recursiveResult.result,
                                recursive: true,
                                steps: 2
                            };
                        }
                    }
                    
                    return {
                        success: true,
                        method: '‰∏ì‰∏öEvalËß£ÂåÖÊèí‰ª∂',
                        result: resultStr,
                        recursive: false
                    };
                } else {
                    throw new Error('EvalÊèí‰ª∂ËøîÂõûÁ©∫ÁªìÊûúÊàñÊú™ÊîπÂèò');
                }
                
            } catch (error) {
                addLog('‚ùå ‰∏ì‰∏öEvalËß£ÂåÖÂ§±Ë¥•: ' + error.message, 'error');
                
                return {
                    success: false,
                    method: 'Ëß£ÂØÜÂ§±Ë¥•',
                    result: null,
                    error: 'EvalËß£ÂåÖÂ§±Ë¥•: ' + error.message
                };
            }
        }
        
        function performDecryption(code) {
            const detection = comprehensiveDetection(code);
            
            if (detection.primaryType === 'AAEncode') {
                return decodeAAEncode(code);
            } else if (detection.primaryType === 'Eval') {
                return decodeEval(code);
            } else {
                return tryOtherDecryptMethods(code);
            }
        }
        
        function updateDetectionPanel(detection) {
            const panel = document.getElementById('detectionPanel');
            const aaIndicator = document.getElementById('aaencodeIndicator');
            const evalIndicator = document.getElementById('evalIndicator');
            
            aaIndicator.classList.remove('show');
            evalIndicator.classList.remove('show');
            window.appData.isAAEncodeMode = false;
            window.appData.isEvalMode = false;
            
            if (detection.primaryType !== 'Unknown') {
                panel.style.display = 'block';
                
                document.getElementById('detectionType').textContent = detection.primaryType;
                document.getElementById('detectionConfidence').textContent = detection.primaryConfidence + '%';
                
                if (detection.primaryType === 'AAEncode') {
                    aaIndicator.classList.add('show');
                    window.appData.isAAEncodeMode = true;
                    document.getElementById('detectionFeatures').textContent = detection.aaResult.patternMatches + '/9';
                    document.getElementById('detectionDetails').textContent = detection.aaResult.ratio + '%Â≠óÁ¨¶Âç†ÊØî';
                } else if (detection.primaryType === 'Eval') {
                    evalIndicator.classList.add('show');
                    window.appData.isEvalMode = true;
                    document.getElementById('detectionFeatures').textContent = detection.evalResult.evalCount + '‰∏™eval';
                    document.getElementById('detectionDetails').textContent = 'ÂµåÂ•óÊ∑±Â∫¶' + detection.evalResult.nestedDepth;
                }
                
                if (detection.hasMultipleEncodings) {
                    aaIndicator.classList.add('show');
                    evalIndicator.classList.add('show');
                    document.getElementById('detectionDetails').textContent = 'Â§öÈáçÁºñÁ†Å';
                }
                
                const confidenceEl = document.getElementById('detectionConfidence');
                if (detection.primaryConfidence >= 90) {
                    confidenceEl.style.color = '#10b981';
                } else if (detection.primaryConfidence >= 70) {
                    confidenceEl.style.color = '#f59e0b';
                } else {
                    confidenceEl.style.color = '#ef4444';
                }
                
                window.appData.lastDetection = detection;
            } else {
                panel.style.display = 'none';
                window.appData.lastDetection = null;
            }
        }
        
        // Áî®Êà∑ÁïåÈù¢ÂáΩÊï∞
        function testAAEncodeInput() {
            const input = document.getElementById('input').value.trim();
            if (!input) {
                showToast('ËØ∑ÂÖàËæìÂÖ•AAEncodeÂØÜÊñá');
                return;
            }
            
            const detection = detectAAEncode(input);
            updateDetectionPanel({ 
                primaryType: detection.isDetected ? 'AAEncode' : 'Unknown', 
                primaryConfidence: detection.confidence,
                aaResult: detection 
            });
            
            if (detection.isDetected) {
                showToast(`üéØ Ê£ÄÊµãÂà∞AAEncodeÊ†ºÂºèÔºÅÁΩÆ‰ø°Â∫¶: ${detection.confidence}%`);
                addLog(`AAEncodeÊ£ÄÊµãÊàêÂäü: ÁΩÆ‰ø°Â∫¶ ${detection.confidence}%, ÁâπÂæÅÂåπÈÖç ${detection.patternMatches}/9`, 'success');
                
                setTimeout(() => {
                    const decodeResult = decodeAAEncode(input);
                    if (decodeResult.success) {
                        displayResult(decodeResult.result);
                        showToast('üéâ AAEncodeËß£ÂØÜÊàêÂäüÔºÅ');
                        addLog(`Ëß£ÂØÜÂÆåÊàêÔºå‰ΩøÁî®ÊñπÊ≥ï: ${decodeResult.method}`, 'success');
                        if (decodeResult.preservedHeader) {
                            addLog('‚ú® Â∑≤‰øùÁïôËÑöÊú¨Â§¥ÈÉ®Ê≥®Èáä', 'info');
                        }
                        if (decodeResult.warning) {
                            addLog(`‚ö†Ô∏è ${decodeResult.warning}`, 'warning');
                        }
                    } else {
                        showToast('‚ùå AAEncodeËß£ÂØÜÂ§±Ë¥•');
                        addLog(decodeResult.error, 'error');
                    }
                }, 500);
            } else {
                showToast(`‚ùå Êú™Ê£ÄÊµãÂà∞AAEncodeÊ†ºÂºè (ÁΩÆ‰ø°Â∫¶: ${detection.confidence}%)`);
                addLog(`AAEncodeÊ£ÄÊµãÂ§±Ë¥•: ÁΩÆ‰ø°Â∫¶‰∏çË∂≥ ${detection.confidence}%`, 'warning');
            }
        }
        
        function testEvalInput() {
    const input = document.getElementById('input').value.trim();
    if (!input) {
        showToast('ËØ∑ÂÖàËæìÂÖ•EvalÂåÖË£ÖÁöÑÂØÜÊñá');
        return;
    }
    
    // üÜï ‰ºòÂÖàÊ£ÄÊµãjsjiamiÔºàÂÆâÂÖ®ÁâàÊú¨Ôºâ
    if (input.includes('jsjiami.com.v5') || input.includes('jsjiami.com.v6') || input.includes('jsjiami.com.v7')) {
        showToast('‚ùå Ê£ÄÊµãÂà∞jsjiamiÊ∑∑Ê∑ÜÔºåÊ≠§Â∑•ÂÖ∑ÊöÇ‰∏çÊîØÊåÅjsjiamiËß£ÂØÜ');
        addLog('Ê£ÄÊµãÂà∞jsjiamiÊ∑∑Ê∑Ü‰ª£Á†ÅÔºåÂª∫ËÆÆ‰ΩøÁî®‰∏ìÈó®ÁöÑjsjiamiËß£ÂØÜÂ∑•ÂÖ∑', 'warning');
        
        // ÂÆâÂÖ®Ë∞ÉÁî®updateDetectionPanelÔºàÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºâ
        if (typeof updateDetectionPanel === 'function') {
            updateDetectionPanel({ 
                primaryType: 'jsjiami', 
                primaryConfidence: 95,
                evalResult: { isDetected: true, confidence: 95 }
            });
        }
        return;
    }
    
    const detection = detectEval(input);
    
    // ÂÆâÂÖ®Ë∞ÉÁî®updateDetectionPanel
    if (typeof updateDetectionPanel === 'function') {
        updateDetectionPanel({ 
            primaryType: detection.isDetected ? 'Eval' : 'Unknown', 
            primaryConfidence: detection.confidence,
            evalResult: detection 
        });
    }
    
    if (detection.isDetected) {
        showToast(`üéØ Ê£ÄÊµãÂà∞EvalÂåÖË£ÖÔºÅÁΩÆ‰ø°Â∫¶: ${detection.confidence}%`);
        addLog(`EvalÊ£ÄÊµãÊàêÂäü: ÁΩÆ‰ø°Â∫¶ ${detection.confidence}%, evalÊï∞Èáè ${detection.evalCount}, ÂµåÂ•óÊ∑±Â∫¶ ${detection.nestedDepth}`, 'success');
        
        setTimeout(() => {
            const decodeResult = decodeEval(input);
            if (decodeResult.success) {
                displayResult(decodeResult.result);
                showToast('üéâ EvalËß£ÂåÖÊàêÂäüÔºÅ');
                addLog(`Ëß£ÂØÜÂÆåÊàêÔºå‰ΩøÁî®ÊñπÊ≥ï: ${decodeResult.method}`, 'success');
                if (decodeResult.recursive) {
                    addLog(`üîÑ ÊâßË°å‰∫Ü${decodeResult.steps}Ê≠•ÈÄíÂΩíËß£ÂØÜ`, 'info');
                }
                if (decodeResult.warning) {
                    addLog(`‚ö†Ô∏è ${decodeResult.warning}`, 'warning');
                }
            } else {
                showToast('‚ùå EvalËß£ÂåÖÂ§±Ë¥•');
                addLog(decodeResult.error, 'error');
            }
        }, 500);
    } else {
        showToast(`‚ùå Êú™Ê£ÄÊµãÂà∞EvalÂåÖË£Ö (ÁΩÆ‰ø°Â∫¶: ${detection.confidence}%)`);
        addLog(`EvalÊ£ÄÊµãÂ§±Ë¥•: ÁΩÆ‰ø°Â∫¶‰∏çË∂≥ ${detection.confidence}%`, 'warning');
    }
}
        
        function autoDetectAndDecrypt() {
            const input = document.getElementById('input').value.trim();
            if (!input) {
                showToast('ËØ∑ÂÖàËæìÂÖ•ÈúÄË¶ÅËß£ÂØÜÁöÑ‰ª£Á†Å');
                return;
            }
            
            addLog('ü§ñ ÂºÄÂßãÊô∫ËÉΩÊ£ÄÊµã...', 'info');
            
            const detection = comprehensiveDetection(input);
            updateDetectionPanel(detection);
            
            if (detection.primaryType !== 'Unknown') {
                addLog(`üéØ Ê£ÄÊµãÂà∞${detection.primaryType}Ê†ºÂºè (ÁΩÆ‰ø°Â∫¶: ${detection.primaryConfidence}%)`, 'success');
                
                const decodeResult = performDecryption(input);
                if (decodeResult.success) {
                    displayResult(decodeResult.result);
                    showToast(`üéâ ${detection.primaryType}Ëá™Âä®Ëß£ÂØÜÊàêÂäüÔºÅ`);
                    addLog(`Ëá™Âä®Ëß£ÂØÜÂÆåÊàê: ${decodeResult.method}`, 'success');
                    if (decodeResult.preservedHeader) {
                        addLog('‚ú® Â§¥ÈÉ®Ê≥®ÈáäÂ∑≤‰øùÁïô', 'info');
                    }
                    if (decodeResult.recursive) {
                        addLog(`üîÑ ÊâßË°å‰∫ÜÈÄíÂΩíËß£ÂØÜ`, 'info');
                    }
                    return;
                } else {
                    addLog(`${detection.primaryType}Ëß£ÂØÜÂ§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï...`, 'warning');
                }
            }
            
            addLog('üîç Ê£ÄÊµãÂÖ∂‰ªñÁºñÁ†ÅÊ†ºÂºè...', 'info');
            
            tryOtherDecryptMethods(input).then(result => {
                if (result.success) {
                    displayResult(result.content);
                    showToast(`üéâ ${result.method}Ëß£ÂØÜÊàêÂäüÔºÅ`);
                    addLog(`Ëá™Âä®Ëß£ÂØÜÂÆåÊàê: ${result.method}`, 'success');
                } else {
                    showToast('‚ùå Êú™ËÉΩËá™Âä®ËØÜÂà´ÁºñÁ†ÅÊ†ºÂºè');
                    addLog('Êô∫ËÉΩÊ£ÄÊµãÊú™ÊâæÂà∞ÊîØÊåÅÁöÑÁºñÁ†ÅÊ†ºÂºè', 'warning');
                }
            });
        }
        
        function loadDemoCode() {
            const demoTypes = ['aaencode', 'eval', 'mixed'];
            const selectedType = demoTypes[Math.floor(Math.random() * demoTypes.length)];
            
            let demoCode = '';
            
            if (selectedType === 'aaencode') {
                demoCode = `// AAEncodeÊºîÁ§∫‰ª£Á†Å
// ‰ΩúËÄÖ: ÊºîÁ§∫Áî®Êà∑
// Êó∂Èó¥: 2024-01-01
// ËØ¥Êòé: ËøôÊÆµÊ≥®ÈáäÂ∞ÜË¢´‰øùÁïô

ÔæüœâÔæüÔæâ= /ÔΩÄÔΩç'ÔºâÔæâ ~‚îª‚îÅ‚îª   //*'‚àáÔΩÄ*/ ['_']; o=(ÔæüÔΩ∞Ôæü)  =_=3; c=(ÔæüŒòÔæü) =(ÔæüÔΩ∞Ôæü)-(ÔæüÔΩ∞Ôæü); (Ôæü–îÔæü) =(ÔæüŒòÔæü)= (o^_^o)/ (o^_^o);(Ôæü–îÔæü)={ÔæüŒòÔæü: '_' ,ÔæüœâÔæüÔæâ : ((ÔæüœâÔæüÔæâ==3) +'_') [ÔæüŒòÔæü] ,ÔæüÔΩ∞ÔæüÔæâ :(ÔæüœâÔæüÔæâ+ '_')[o^_^o -(ÔæüŒòÔæü)] ,Ôæü–îÔæüÔæâ:((ÔæüÔΩ∞Ôæü==3) +'_')[ÔæüÔΩ∞Ôæü] }; (Ôæü–îÔæü) [ÔæüŒòÔæü] =((ÔæüœâÔæüÔæâ==3) +'_') [c^_^o];(Ôæü–îÔæü) ['c'] = ((Ôæü–îÔæü)+'_') [ (ÔæüÔΩ∞Ôæü)+(ÔæüÔΩ∞Ôæü)-(ÔæüŒòÔæü) ];(Ôæü–îÔæü) ['o'] = ((Ôæü–îÔæü)+'_') [ÔæüŒòÔæü];(ÔæüoÔæü)=(Ôæü–îÔæü) ['c']+(Ôæü–îÔæü) ['o']+(ÔæüœâÔæüÔæâ +'_')[ÔæüŒòÔæü]+ ((ÔæüœâÔæüÔæâ==3) +'_') [ÔæüÔΩ∞Ôæü] + ((Ôæü–îÔæü) +'_') [(ÔæüÔΩ∞Ôæü)+(ÔæüÔΩ∞Ôæü)]+ ((ÔæüÔΩ∞Ôæü==3) +'_') [ÔæüŒòÔæü]+((ÔæüÔΩ∞Ôæü==3) +'_') [(ÔæüÔΩ∞Ôæü) - (ÔæüŒòÔæü)]+(Ôæü–îÔæü) ['c']+((Ôæü–îÔæü)+'_') [(ÔæüÔΩ∞Ôæü)+(ÔæüÔΩ∞Ôæü)]+ (Ôæü–îÔæü) ['o']+((ÔæüÔΩ∞Ôæü==3) +'_') [ÔæüŒòÔæü];(Ôæü–îÔæü) ['_'] = (o^_^o) [ÔæüoÔæü] [ÔæüoÔæü];(ÔæüŒµÔæü)=((ÔæüÔΩ∞Ôæü==3) +'_') [ÔæüŒòÔæü]+ (Ôæü–îÔæü) .Ôæü–îÔæüÔæâ+((Ôæü–îÔæü)+'_') [(ÔæüÔΩ∞Ôæü) + (ÔæüÔΩ∞Ôæü)]+((ÔæüÔΩ∞Ôæü==3) +'_') [o^_^o -ÔæüŒòÔæü]+((ÔæüÔΩ∞Ôæü==3) +'_') [ÔæüŒòÔæü]+ (ÔæüœâÔæüÔæâ +'_') [ÔæüŒòÔæü]; (ÔæüÔΩ∞Ôæü)+=(ÔæüŒòÔæü); (Ôæü–îÔæü)[ÔæüŒµÔæü]='\\\\'; (Ôæü–îÔæü).ÔæüŒòÔæüÔæâ=(Ôæü–îÔæü+ ÔæüÔΩ∞Ôæü)[o^_^o -(ÔæüŒòÔæü)];(oÔæüÔΩ∞Ôæüo)=(ÔæüœâÔæüÔæâ +'_')[c^_^o];(Ôæü–îÔæü) [ÔæüoÔæü]='\"';(Ôæü–îÔæü) ['_'] ( (Ôæü–îÔæü) ['_'] (ÔæüŒµÔæü+(Ôæü–îÔæü)[ÔæüoÔæü]+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüÔΩ∞Ôæü)+ (ÔæüŒòÔæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüÔΩ∞Ôæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((o^_^o) +(o^_^o))+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (c^_^o)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüÔΩ∞Ôæü)+ ((o^_^o) - (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüŒòÔæü)+ (c^_^o)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüÔΩ∞Ôæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ ((ÔæüÔΩ∞Ôæü) + (o^_^o))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüÔΩ∞Ôæü)+ (c^_^o)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüŒòÔæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüŒòÔæü)+ (ÔæüÔΩ∞Ôæü)+ (ÔæüÔΩ∞Ôæü)+ (Ôæü–îÔæü)[ÔæüŒµÔæü]+(ÔæüÔΩ∞Ôæü)+ ((ÔæüÔΩ∞Ôæü) + (ÔæüŒòÔæü))+ (Ôæü–îÔæü)[ÔæüoÔæü]) (ÔæüŒòÔæü)) ('_');`;
            } else if (selectedType === 'eval') {
                demoCode = `// EvalÂåÖË£ÖÊºîÁ§∫‰ª£Á†Å
// ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑevalÂåÖË£ÖÁ§∫‰æã

eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('0("1 2!");',3,3,'console|Hello|World'.split('|'),0,{}))

// Êõ¥Â§çÊùÇÁöÑÂµåÂ•óevalÁ§∫‰æã
eval("eval(\\"console.log('ËøôÊòØÂµåÂ•óÁöÑeval');\\")");

// Â∏¶ÊúâÂ≠óÁ¨¶‰∏≤ÁºñÁ†ÅÁöÑeval
eval(unescape('%63%6f%6e%73%6f%6c%65%2e%6c%6f%67%28%22%48%65%6c%6c%6f%20%57%6f%72%6c%64%22%29%3b'));`;
            } else {
                demoCode = `// Ê∑∑ÂêàÁºñÁ†ÅÊºîÁ§∫ - Êó¢ÊúâAAEncodeÂèàÊúâEval
// ËØ∑Ê≥®ÊÑèÔºöËøôÂè™ÊòØÊºîÁ§∫ÔºåÂÆûÈôÖÂèØËÉΩÊõ¥Â§çÊùÇ

// Á¨¨‰∏ÄÂ±ÇÔºöEvalÂåÖË£Ö
eval(function(){
    // Á¨¨‰∫åÂ±ÇÔºöÂèØËÉΩÊòØAAEncode
    var code = "ÔæüœâÔæüÔæâ= /ÔΩÄÔΩç'ÔºâÔæâ ~‚îª‚îÅ‚îª   //*'‚àáÔΩÄ*/";
    console.log("Ê∑∑ÂêàÁºñÁ†ÅÊºîÁ§∫");
    return "alert('Ëß£ÂØÜÊàêÂäü!');";
}());

// Âè¶‰∏Ä‰∏™Â§çÊùÇÁ§∫‰æã
eval("var x = 'Ôæü–îÔæü'; console.log('Ê£ÄÊµãÂà∞ÁâπÊÆäÂ≠óÁ¨¶');");`;
            }
            
            document.getElementById('input').value = demoCode;
            showToast(`üìù Â∑≤Âä†ËΩΩ${selectedType === 'aaencode' ? 'AAEncode' : selectedType === 'eval' ? 'Eval' : 'Ê∑∑ÂêàÁºñÁ†Å'}ÊºîÁ§∫‰ª£Á†Å`);
            addLog(`Âä†ËΩΩ${selectedType}ÊºîÁ§∫‰ª£Á†Å`, 'info');
            
            setTimeout(() => {
                const detection = comprehensiveDetection(demoCode);
                updateDetectionPanel(detection);
                if (detection.primaryType !== 'Unknown') {
                    showToast(`üéØ Ëá™Âä®Ê£ÄÊµã: ${detection.primaryType}Ê†ºÂºè (${detection.primaryConfidence}%ÁΩÆ‰ø°Â∫¶)`);
               }
           }, 500);
       }
       
       function showRemoteUrlDialog() {
    const url = prompt('ËØ∑ËæìÂÖ•ËøúÁ®ãÊñá‰ª∂URLÂú∞ÂùÄ:', '');
    if (url && url.trim()) {
        // Ëá™Âä®Ê∑ªÂä†ÂçèËÆÆÔºàÂ¶ÇÊûúÁî®Êà∑Ê≤°ÊúâËæìÂÖ•Ôºâ
        let finalUrl = url.trim();
        if (!finalUrl.startsWith('http://') && !finalUrl.startsWith('https://')) {
            finalUrl = 'https://' + finalUrl;
        }
        loadRemoteFile(finalUrl);
    }
}

function loadRemoteFile(url) {
    addLog('ÂºÄÂßãÂä†ËΩΩËøúÁ®ãÊñá‰ª∂: ' + url, 'info');
    
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('ÁΩëÁªúÂìçÂ∫îÈîôËØØ: ' + response.status);
            }
            return response.text();
        })
        .then(content => {
            document.getElementById('input').value = content;
            // detectCode(); // Âà†Èô§ËøôË°å
            addLog('ËøúÁ®ãÊñá‰ª∂Âä†ËΩΩÊàêÂäü', 'success');
            showToast('‚úÖ ËøúÁ®ãÊñá‰ª∂Âä†ËΩΩÊàêÂäü');
        })
        .catch(error => {
            addLog('ËøúÁ®ãÊñá‰ª∂Âä†ËΩΩÂ§±Ë¥•: ' + error.message, 'error');
            showToast('‚ùå ËøúÁ®ãÊñá‰ª∂Âä†ËΩΩÂ§±Ë¥•: ' + error.message);
        });
}
       
       async function pasteFromClipboard() {
           try {
               const text = await navigator.clipboard.readText();
               if (text) {
                   document.getElementById('input').value = text;
                   showToast('üìã Ââ™Ë¥¥ÊùøÂÜÖÂÆπÂ∑≤Á≤òË¥¥');
                   addLog('‰ªéÂâ™Ë¥¥ÊùøÁ≤òË¥¥ÂÜÖÂÆπ', 'success');
                   
                   setTimeout(() => {
                       const detection = comprehensiveDetection(text);
                       updateDetectionPanel(detection);
                       if (detection.primaryType !== 'Unknown') {
                           showToast(`üéØ Ê£ÄÊµãÂà∞${detection.primaryType}ÔºÅÁΩÆ‰ø°Â∫¶: ${detection.primaryConfidence}%`);
                       }
                   }, 300);
               } else {
                   showToast('‚ùå Ââ™Ë¥¥Êùø‰∏∫Á©∫');
               }
           } catch (error) {
               addLog('Ââ™Ë¥¥ÊùøËÆøÈóÆÂ§±Ë¥•: ' + error.message, 'error');
               showToast('‚ùå Êó†Ê≥ïËÆøÈóÆÂâ™Ë¥¥ÊùøÔºåËØ∑ÊâãÂä®Á≤òË¥¥');
           }
       }
       
       // Êô∫ËÉΩÊ∏ÖÁêÜËæìÂÖ• - Ë∂ÖÁÆÄÂåñÁâà
function cleanInput() {
    const inputEl = document.getElementById('input');
    const input = inputEl.value.trim();
    
    if (!input) {
        showToast('ËØ∑ÂÖàËæìÂÖ•‰ª£Á†Å');
        return;
    }

    addLog('ÂºÄÂßãÊô∫ËÉΩÊ∏ÖÁêÜ‰ª£Á†Å...', 'info');

    // Áªü‰∏ÄÁöÑÊèêÂèñÊ®°ÂºèÈÖçÁΩÆ
    const patterns = [
        {
            name: 'jsjiamiÊ†ºÂºè(ÂçïÂºïÂè∑)',
            test: input => input.indexOf(';var encode_version') !== -1,
            extract: input => {
                const jsjiamiStart = input.indexOf(';var encode_version');
                const fromStart = input.substring(jsjiamiStart);
                const jsjiamiEnd = fromStart.indexOf(";encode_version = 'jsjiami.com.v5';");
                if (jsjiamiEnd !== -1) {
                    return fromStart.substring(0, jsjiamiEnd + ";encode_version = 'jsjiami.com.v5';".length);
                }
                return null;
            }
        },
        {
            name: 'jsjiamiÊ†ºÂºè(ÂèåÂºïÂè∑)',
            test: input => input.indexOf(';var encode_version') !== -1,
            extract: input => {
                const jsjiamiStart = input.indexOf(';var encode_version');
                const fromStart = input.substring(jsjiamiStart);
                const jsjiamiEnd = fromStart.indexOf(';encode_version = "jsjiami.com.v5";');
                if (jsjiamiEnd !== -1) {
                    return fromStart.substring(0, jsjiamiEnd + ';encode_version = "jsjiami.com.v5";'.length);
                }
                return null;
            }
        }
    ];

    // Â∞ùËØïÊèêÂèñÁâπÂÆöÊ†ºÂºè
    for (const pattern of patterns) {
        if (pattern.test(input)) {
            const extracted = pattern.extract(input);
            if (extracted) {
                inputEl.value = extracted;
                showToast(`üéØ ÊèêÂèñ${pattern.name}ÂÆåÊàê`);
                addLog(`ÊèêÂèñ: ${input.length} ‚Üí ${extracted.length} Â≠óÁ¨¶`, 'success');
                return;
            }
        }
    }

    // Âü∫Á°ÄÊ∏ÖÁêÜ
    let cleaned = input
        .replace(/\/\/.*$/gm, '')                    // ÂçïË°åÊ≥®Èáä
        .replace(/\/\*[\s\S]*?\*\//g, '')           // Â§öË°åÊ≥®Èáä
        .replace(/<!--[\s\S]*?-->/g, '')            // HTMLÊ≥®Èáä
        .replace(/^\s*console\.(log|warn|error)\s*\([^)]*\)\s*;?\s*$/gm, '') // consoleËØ≠Âè•
        .replace(/^\s*alert\s*\([^)]*\)\s*;?\s*$/gm, '') // alertËØ≠Âè•
        .replace(/^\s*[\r\n]+/gm, '')               // Á©∫Ë°å
        .replace(/\s+/g, ' ')                       // Â§ö‰ΩôÁ©∫ÁôΩ
        .trim();

    // Êõ¥Êñ∞ÁªìÊûú
    if (cleaned === input) {
        showToast('üîç Êú™ÂèëÁé∞ÈúÄË¶ÅÊ∏ÖÁêÜÁöÑÂÜÖÂÆπ');
        addLog('‰ª£Á†ÅÂ∑≤ÁªèÊòØÁ∫ØÂáÄÊ†ºÂºè', 'info');
    } else {
        inputEl.value = cleaned;
        showToast('üßπ ‰ª£Á†ÅÊ∏ÖÁêÜÂÆåÊàê');
        addLog(`Ê∏ÖÁêÜ: ${input.length} ‚Üí ${cleaned.length} Â≠óÁ¨¶`, 'success');
    }
}

// Êô∫ËÉΩÈ¢ÑÂ§ÑÁêÜÊ∑∑ÂêàÂØÜÊñá
function preprocessCiphertext(input) {
    addLog('ÊâßË°åÊô∫ËÉΩÈ¢ÑÂ§ÑÁêÜ...', 'info');

    let processed = input
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        .replace(/<!--[\s\S]*?-->/g, '')
        .replace(/^\s*\/\/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*$/gm, '')
        .replace(/^\s*\/\/Ëß£ÂØÜËÑöÊú¨.*$/gm, '')
        .replace(/^\s*\/\/.*?(Ëß£ÂØÜ|ËÑöÊú¨|ËØ¥Êòé|Ê≥®Èáä|ÂéüÂßã|Ê∑∑Ê∑Ü|ÁªìÊûú).*$/gm, '');

    const patterns = [
        {
            name: 'jsjiamiÊ†ºÂºè(ÂçïÂºïÂè∑)',
            pattern: /;var encode_version[\s\S]*?;encode_version = 'jsjiami\.com\.v\d+';/,
            extract: match => match[0]
        },
        {
            name: 'jsjiamiÊ†ºÂºè(ÂèåÂºïÂè∑)', 
            pattern: /;var encode_version[\s\S]*?;encode_version = "jsjiami\.com\.v\d+";/,
            extract: match => match[0]
        },
        {
            name: 'evalÂåÖË£ÖÁöÑjsjiami',
            pattern: /eval\s*\(\s*(['"`])(.*?jsjiami\.com\.v\d+.*?)\1\s*\)/s,
            extract: match => match[2]
        },
        {
            name: 'AAEncodeÊ∑∑Ê∑Ü',
            pattern: /(ÔæüœâÔæüÔæâ.*?ÔæüŒòÔæü.*?)/s,
            extract: match => match[1]
        },
        {
            name: 'evalÂåÖË£Ö',
            pattern: /eval\s*\(\s*(['"`])((?:\\u[0-9a-fA-F]{4}|[^"'`\\]|\\.){20,})\1\s*\)/s,
            extract: match => match[2]
        },
        {
            name: 'FunctionÊûÑÈÄ†Âô®',
            pattern: /(?:new\s+)?Function\s*\(\s*(['"`])((?:\\u[0-9a-fA-F]{4}|[^"'`\\]|\\.){20,})\1\s*\)/s,
            extract: match => match[2]
        }
    ];

    for (const pattern of patterns) {
        const matches = processed.match(pattern.pattern);
        if (matches) {
            const extracted = pattern.extract(matches);
            if (extracted && extracted.length > 50) {
                addLog(`Êô∫ËÉΩÊèêÂèñ${pattern.name}Ê†ºÂºèÂØÜÊñá`, 'success');
                return extracted;
            }
        }
    }

    return processed
        .replace(/^\s*\/\/\s*(ÂéüÂßã|ÂéüÊñá|ÊòéÊñá).*$/gm, '')
        .replace(/^\s*console\.log\s*\(.*?\)\s*;?\s*$/gm, '')
        .replace(/^\s*alert\s*\(.*?\)\s*;?\s*$/gm, '')
        .replace(/^\s*[\r\n]/gm, '')
        .replace(/^\s+/gm, '')
        .replace(/\s+/g, ' ')
        .trim();
}

// Ê£ÄÊü•ÊòØÂê¶‰∏∫Ê∑∑ÂêàÂÜÖÂÆπ
function checkIfMixedContent(input) {
    const mixedContentIndicators = [
        /\/\/.*$/m,
        /\/\*[\s\S]*?\*\//,
        /<!--[\s\S]*?-->/,
        /[\u4e00-\u9fff]/,
        /(ÂéüÂßã‰ª£Á†Å|ÂéüÊñá|ÊòéÊñá|Ëß£ÂØÜÁªìÊûú|Ëß£ÂØÜÂÆåÊàê)/,
        /<[^>]+>/,
        /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/,
        /(console\.log|alert|document\.write)\s*\(/,
        /eval\s*\(.*?\).*eval\s*\(/s,
        /(Ëß£ÂØÜËÑöÊú¨|Ê∑∑Ê∑ÜÂ∑•ÂÖ∑|Âä†ÂØÜÂ∑•ÂÖ∑)/
    ];

    for (const indicator of mixedContentIndicators) {
        if (indicator.test(input)) {
            return true;
        }
    }

    const lines = input.split('\n');
    if (lines.length > 10) {
        const nonCipherLines = lines.filter(line => {
            const trimmedLine = line.trim();
            return trimmedLine.length > 0 &&
                !(/^[A-Za-z0-9+/=\\u]+$/.test(trimmedLine)) &&
                !(/^[0-9a-fA-F\s]+$/.test(trimmedLine)) &&
                !(/^[\x20-\x7E]*$/.test(trimmedLine));
        });

        if (nonCipherLines.length > lines.length * 0.3) {
            return true;
        }
    }

    return false;
}

// È™åËØÅËæìÂÖ•Ë¥®Èáè
function validateInput() {
    const input = document.getElementById('input').value.trim();
    if (!input) {
        showToast('ËØ∑ÂÖàËæìÂÖ•‰ª£Á†Å');
        return;
    }
    
    addLog('üîç ÂºÄÂßãË¥®ÈáèÊ£ÄÊü•...', 'info');
    
    const issues = [];
    const warnings = [];
    const suggestions = [];
    
    // Âü∫Á°ÄÊ£ÄÊü•
    if (input.length < 50) {
        issues.push('‰ª£Á†ÅÈïøÂ∫¶ËøáÁü≠(<50Â≠óÁ¨¶)');
        suggestions.push('Á°Æ‰øùÂ§çÂà∂‰∫ÜÂÆåÊï¥ÁöÑ‰ª£Á†ÅÂÜÖÂÆπ');
    }
    
    if (input.length > 500000) {
        warnings.push('‰ª£Á†ÅÈïøÂ∫¶ËøáÈïø(>500KB)');
        suggestions.push('ËÄÉËôëÂàÜÊÆµÂ§ÑÁêÜÂ§ßÊñá‰ª∂');
    }
    
    // Ê£ÄÊµã‰ª£Á†ÅÁ±ªÂûã
    const detection = comprehensiveDetection(input);
    
    if (detection.primaryType !== 'Unknown') {
        // Â∑≤ËØÜÂà´ÁöÑÂØÜÊñáÊ†ºÂºè
        addLog(`üéØ Ê£ÄÊµãÂà∞Ê†ºÂºè: ${detection.primaryType} (ÁΩÆ‰ø°Â∫¶: ${detection.primaryConfidence}%)`, 'info');
        
        if (detection.primaryConfidence < 70) {
            warnings.push(`${detection.primaryType}ÁΩÆ‰ø°Â∫¶ËæÉ‰Ωé (${detection.primaryConfidence}%)`);
            suggestions.push('ÂèØËÉΩÈúÄË¶ÅÊ∏ÖÁêÜÊàñÊ†ºÂºè‰∏çÂÆåÊï¥');
        }
        
        // ÁâπÂÆöÊ†ºÂºèÁöÑËØ¶ÁªÜÊ£ÄÊü•
        if (detection.primaryType === 'AAEncode' && detection.aaResult.patternMatches < 3) {
            warnings.push('AAEncodeÁâπÂæÅÊ®°Âºè‰∏çË∂≥');
            suggestions.push('Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂÆåÊï¥ÁöÑAAEncode‰ª£Á†Å');
        }
        
        if (detection.primaryType === 'Eval' && detection.evalResult.evalCount < 2) {
            warnings.push('EvalË∞ÉÁî®Ê¨°Êï∞ËæÉÂ∞ë');
            suggestions.push('ÂèØËÉΩ‰∏çÊòØÊ†áÂáÜÁöÑEvalÊ∑∑Ê∑Ü');
        }
        
        if (detection.primaryType === 'jsjiami') {
            if (!input.includes('jsjiami.com.v')) {
                warnings.push('jsjiamiÊ†áËØÜ‰∏çÂÆåÊï¥');
                suggestions.push('Á°Æ‰øùÂåÖÂê´ÂÆåÊï¥ÁöÑjsjiamiÊ†áËØÜ');
            }
        }
        
        // Ê£ÄÊü•Â§öÈáçÁºñÁ†Å
        if (detection.hasMultipleEncodings) {
            warnings.push('Ê£ÄÊµãÂà∞Â§öÈáçÁºñÁ†Å');
            suggestions.push('ÂèØËÉΩÈúÄË¶ÅÂ§öÊ¨°Ëß£ÂØÜ');
        }
        
    } else {
        // Êú™ËØÜÂà´Ê†ºÂºèÁöÑÊ∏ÖÊ¥ÅÂ∫¶Ê£ÄÊü•
        addLog('üîç Êú™ËØÜÂà´ÁöÑÊ†ºÂºèÔºåËøõË°åÊ∏ÖÊ¥ÅÂ∫¶Ê£ÄÊü•', 'info');
        
        if (/[\u4e00-\u9fff]/.test(input)) {
            issues.push('ÂåÖÂê´‰∏≠ÊñáÂ≠óÁ¨¶');
            suggestions.push('‰ΩøÁî®Êô∫ËÉΩÊ∏ÖÁêÜÂäüËÉΩÁßªÈô§Ê≥®Èáä');
        }
        
        if (/\/\/|\/\*|\*\/|<!--/.test(input)) {
            issues.push('ÂåÖÂê´Ê≥®ÈáäÁ¨¶Âè∑');
            suggestions.push('‰ΩøÁî®Êô∫ËÉΩÊ∏ÖÁêÜÂäüËÉΩÁßªÈô§Ê≥®Èáä');
        }
        
        if (/<[^>]+>/.test(input)) {
            issues.push('ÂåÖÂê´HTMLÊ†áÁ≠æ');
            suggestions.push('ÊèêÂèñscriptÊ†áÁ≠æÂÜÖÁöÑ‰ª£Á†ÅÂÜÖÂÆπ');
        }
        
        if (/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(input)) {
            issues.push('ÂåÖÂê´Êó∂Èó¥Êà≥');
            suggestions.push('ÁßªÈô§Ëß£ÂØÜËÑöÊú¨ÁöÑÊó∂Èó¥‰ø°ÊÅØ');
        }
        
        if (input.includes('ÂéüÂßã‰ª£Á†Å') || input.includes('ÂéüÊñá') || input.includes('ÊòéÊñá')) {
            issues.push('ÂåÖÂê´ÂéüÊñáÊ†áËØÜ');
            suggestions.push('ÁßªÈô§ÂéüÂßã‰ª£Á†ÅËØ¥ÊòéÈÉ®ÂàÜ');
        }
        
        if (input.includes('Ëß£ÂØÜÂÆåÊàê') || input.includes('Ëß£ÂØÜÁªìÊûú')) {
            issues.push('ÂåÖÂê´Ëß£ÂØÜÁªìÊûúÊ†áËØÜ');
            suggestions.push('Âè™‰øùÁïôÂØÜÊñáÈÉ®ÂàÜ');
        }
        
        if (/console\.log|alert|document\.write/.test(input)) {
            warnings.push('ÂåÖÂê´Ë∞ÉËØï‰ª£Á†Å');
            suggestions.push('ÁßªÈô§Ë∞ÉËØïËæìÂá∫ËØ≠Âè•');
        }
    }
    
    // ËÆ°ÁÆóË¥®ÈáèËØÑÂàÜ
    let score = 100;
    score -= issues.length * 25;
    score -= warnings.length * 10;
    score = Math.max(0, score);
    
    // ÊòæÁ§∫ÁªìÊûú
    addLog(`üìä Ë¥®ÈáèËØÑÂàÜ: ${score}/100`, score >= 80 ? 'success' : score >= 60 ? 'warning' : 'error');
    
    if (issues.length > 0) {
        addLog(`‚ùå ÂèëÁé∞ÈóÆÈ¢ò: ${issues.join(', ')}`, 'error');
    }
    
    if (warnings.length > 0) {
        addLog(`‚ö†Ô∏è Ë≠¶Âëä: ${warnings.join(', ')}`, 'warning');
    }
    
    if (suggestions.length > 0) {
        addLog(`üí° Âª∫ËÆÆ: ${suggestions.join('; ')}`, 'info');
    }
    
    // ÊÄªÁªìÂíåÂª∫ËÆÆ
    if (score >= 90) {
        showToast('‚úÖ ‰ª£Á†ÅË¥®Èáè‰ºòÁßÄÔºÅ');
        addLog('‰ª£Á†ÅË¥®ÈáèÊ£ÄÊü•ÈÄöËøáÔºåÂèØ‰ª•Áõ¥Êé•Ëß£ÂØÜ', 'success');
    } else if (score >= 70) {
        showToast('üëç ‰ª£Á†ÅË¥®ÈáèËâØÂ•Ω');
        addLog('‰ª£Á†ÅË¥®ÈáèËâØÂ•ΩÔºåÂª∫ËÆÆÁõ¥Êé•Ëß£ÂØÜ', 'success');
    } else if (score >= 50) {
        showToast('‚ö†Ô∏è ‰ª£Á†ÅË¥®Èáè‰∏ÄËà¨');
        addLog('Âª∫ËÆÆ‰ΩøÁî®Êô∫ËÉΩÊ∏ÖÁêÜÂäüËÉΩÂêéÂÜçËß£ÂØÜ', 'warning');
    } else {
        showToast('‚ùå ‰ª£Á†ÅË¥®ÈáèËæÉÂ∑Æ');
        addLog('Âº∫ÁÉàÂª∫ËÆÆÂÖàËøõË°åÊô∫ËÉΩÊ∏ÖÁêÜ', 'error');
    }
}

// Ê∏ÖÁ©∫ËæìÂÖ•
function clearInput() {
    document.getElementById('input').value = '';
    const remoteUrlElement = document.getElementById('remoteUrl');
    if (remoteUrlElement) {
        remoteUrlElement.value = '';
    }
    showToast('‰ª£Á†ÅËæìÂÖ•Â∑≤Ê∏ÖÁ©∫');
    addLog('Ê∏ÖÁ©∫‰ª£Á†ÅËæìÂÖ•ÂÜÖÂÆπ', 'info');
}
       
       async function startDecrypt() {
           const input = document.getElementById('input').value.trim();
           
           if (!input) {
               showToast('ËØ∑ÂÖàËæìÂÖ•ÈúÄË¶ÅËß£ÂØÜÁöÑ‰ª£Á†Å');
               return;
           }
           
           try {
               addLog('üöÄ ÂºÄÂßãËß£ÂØÜÊµÅÁ®ã...', 'info');
               displayResult('');
               setProgress(0);
               
               const detection = comprehensiveDetection(input);
               updateDetectionPanel(detection);
               
               if (detection.primaryType !== 'Unknown') {
                   addLog(`üéØ Ê£ÄÊµãÂà∞${detection.primaryType} (ÁΩÆ‰ø°Â∫¶: ${detection.primaryConfidence}%)`, 'info');
                   
                   setProgress(30);
                   const decodeResult = performDecryption(input);
                   setProgress(80);
                   
                   if (decodeResult.success) {
                       displayResult(decodeResult.result);
                       showToast(`üéâ ${detection.primaryType}Ëß£ÂØÜÊàêÂäüÔºÅ`);
                       addLog(`Ëß£ÂØÜÂÆåÊàê: ${decodeResult.method}`, 'success');
                       
                       if (decodeResult.preservedHeader) {
                           addLog('‚ú® Â§¥ÈÉ®Ê≥®ÈáäÂ∑≤‰øùÁïô', 'info');
                       }
                       if (decodeResult.recursive) {
                           addLog(`üîÑ ÊâßË°å‰∫Ü${decodeResult.steps || 'Â§ö'}Ê≠•ÈÄíÂΩíËß£ÂØÜ`, 'info');
                       }
                       if (decodeResult.warning) {
                           addLog(`‚ö†Ô∏è ${decodeResult.warning}`, 'warning');
                       }
                       
                       setProgress(100);
                       
                       document.getElementById('output').scrollIntoView({ 
                           behavior: 'smooth', 
                           block: 'center' 
                       });
                       return;
                   } else {
                       addLog(`${detection.primaryType}Ëß£ÂØÜÂ§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï`, 'warning');
                   }
               }
               
               addLog('üîç Â∞ùËØïÂÖ∂‰ªñËß£ÂØÜÊñπÊ≥ï...', 'info');
               setProgress(50);
               
               const result = await tryOtherDecryptMethods(input);
               if (result.success) {
                   displayResult(result.content);
                   showToast(`üéâ ${result.method}Ëß£ÂØÜÊàêÂäüÔºÅ`);
                   addLog(`Ëß£ÂØÜÂÆåÊàê: ${result.method}`, 'success');
                   setProgress(100);
               } else {
                   if (window.appData.token && window.appData.repo) {
                       addLog('üåê ‰ΩøÁî®GitHub ActionsËß£ÂØÜ...', 'info');
                       await submitToGitHub(input);
                       await waitForResult();
                   } else {
                       showToast('‚ùå Ëß£ÂØÜÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ËæìÂÖ•Ê†ºÂºè');
                       addLog('ÊâÄÊúâËß£ÂØÜÊñπÊ≥ïÈÉΩÂ§±Ë¥•‰∫Ü', 'error');
                       setProgress(0);
                   }
               }
               
           } catch (error) {
               addLog('Ëß£ÂØÜÂ§±Ë¥•: ' + error.message, 'error');
               showToast('Ëß£ÂØÜÂ§±Ë¥•: ' + error.message);
               setProgress(0);
           }
       }
       
       async function tryOtherDecryptMethods(input) {
           // Base64Ëß£ÂØÜ
           if (/^[A-Za-z0-9+/]+=*$/.test(input.replace(/\s/g, ''))) {
               try {
                   const decoded = atob(input.replace(/\s/g, ''));
                   if (decoded.length > 10) {
                       return { success: true, method: 'Base64', content: decoded };
                   }
               } catch (e) {
                   // ÁªßÁª≠Â∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï
               }
           }
           
           // URLËß£Á†Å
           if (/%[0-9a-fA-F]{2}/.test(input)) {
               try {
                   const decoded = decodeURIComponent(input);
                   if (decoded !== input) {
                       return { success: true, method: 'URLËß£Á†Å', content: decoded };
                   }
               } catch (e) {
                   // ÁªßÁª≠Â∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï
               }
           }
           
           // ÂçÅÂÖ≠ËøõÂà∂Ëß£ÂØÜ
           if (/^[0-9a-fA-F\s]+$/.test(input) && input.length > 20) {
               try {
                   const hex = input.replace(/\s/g, '');
                   const decoded = hex.replace(/../g, (h) => String.fromCharCode(parseInt(h, 16)));
                   if (decoded.length > 10) {
                       return { success: true, method: 'ÂçÅÂÖ≠ËøõÂà∂', content: decoded };
                   }
               } catch (e) {
                   // ÁªßÁª≠Â∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï
               }
           }
           
           return { success: false, method: null, content: null };
       }
       
       function displayResult(content) {
           const output = document.getElementById('output');
           
           if (!content || content.includes('Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå')) {
               output.innerHTML = '<span style="color: #6b7280;">// Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå...</span>';
               return;
           }
           
           content = content.replace(/<[^>]*>/g, '');
           
           if (content.includes('function') || content.includes('var ') || content.includes('let ') || 
               content.includes('const ') || content.includes('{') || content.includes('}')) {
               output.innerHTML = highlightJS(content);
           } else {
               output.textContent = content;
           }
       }
       
       function highlightJS(code) {
           return code
               .replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&#39;')
               .replace(/\b(function|var|let|const|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|this|typeof|instanceof|in|of|class|extends|import|export|default|async|await|yield|true|false|null|undefined)\b/g, '<span class="hljs-keyword">$1</span>')
               .replace(/(&#39;|&quot;)(.*?)\1/g, '<span class="hljs-string">$1$2$1</span>')
               .replace(/\b(\d+\.?\d*)\b/g, '<span class="hljs-number">$1</span>')
               .replace(/\/\/.*$/gm, '<span class="hljs-comment">$&</span>')
               .replace(/\/\*[\s\S]*?\*\//g, '<span class="hljs-comment">$&</span>')
               .replace(/\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*(?=\()/g, '<span class="hljs-function">$1</span>')
               .replace(/\.([a-zA-Z_$][a-zA-Z0-9_$]*)/g, '.<span class="hljs-property">$1</span>');
       }
       
       function setProgress(percent) {
           document.getElementById('progress').style.width = percent + '%';
       }
       
       async function submitToGitHub(code) {
           if (!window.appData.token || !window.appData.repo) {
               throw new Error('GitHubÈÖçÁΩÆ‰∏çÂÆåÊï¥');
           }
           
           addLog('üì§ Êèê‰∫§‰ª£Á†ÅÂà∞GitHub...', 'info');
           
           const url = `https://api.github.com/repos/${window.appData.repo}/contents/input.js`;
           
           let sha = null;
           try {
               const checkResp = await fetch(url, {
                   headers: {
                       'Authorization': `token ${window.appData.token}`,
                       'Accept': 'application/vnd.github.v3+json'
                   }
               });
               
               if (checkResp.ok) {
                   const data = await checkResp.json();
                   sha = data.sha;
               }
           } catch (e) {
               // Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂàõÂª∫Êñ∞Êñá‰ª∂
           }
           
           const payload = {
               message: `Update input.js - ${new Date().toISOString()}`,
               content: btoa(unescape(encodeURIComponent(code))),
               branch: 'main'
           };
           
           if (sha) payload.sha = sha;
           
           const response = await fetch(url, {
               method: 'PUT',
               headers: {
                   'Authorization': `token ${window.appData.token}`,
                   'Accept': 'application/vnd.github.v3+json',
                   'Content-Type': 'application/json'
               },
               body: JSON.stringify(payload)
           });
           
           if (!response.ok) {
               const error = await response.json();
               throw new Error(`GitHub APIÈîôËØØ: ${error.message}`);
           }
           
           addLog('‚úÖ ‰ª£Á†ÅÂ∑≤Êèê‰∫§ÔºåÁ≠âÂæÖActionsÂ§ÑÁêÜ...', 'success');
       }
       
       async function waitForResult() {
           const startTime = Date.now();
           const timeout = 60000;
           
           return new Promise((resolve) => {
               const checkLoop = async () => {
                   const elapsed = Date.now() - startTime;
                   const progress = Math.min((elapsed / timeout) * 100, 100);
                   setProgress(progress);
                   
                   if (elapsed >= timeout) {
                       addLog('‚è∞ Á≠âÂæÖË∂ÖÊó∂ÔºåÂ∞ùËØïËé∑ÂèñÁªìÊûú...', 'warning');
                       const success = await getResult();
                       if (!success) {
                           showToast('‚è∞ GitHub ActionsÂ§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂêéÁÇπÂáª"Ëé∑ÂèñÁªìÊûú"');
                       }
                       resolve();
                       return;
                   }
                   
                   setTimeout(checkLoop, 3000);
               };
               
               checkLoop();
           });
       }
       
       async function getResult() {
           addLog('üì• Ëé∑ÂèñËß£ÂØÜÁªìÊûú...', 'info');
           
           if (!window.appData.token || !window.appData.repo) {
               showToast('ËØ∑ÂÖàÈÖçÁΩÆGitHub TokenÂíå‰ªìÂ∫ìÂú∞ÂùÄ');
               return false;
           }
           
           const timestamp = Date.now();
           
           try {
               const apiUrl = `https://api.github.com/repos/${window.appData.repo}/contents/output.js`;
               const response = await fetch(`${apiUrl}?ref=main&_=${timestamp}`, {
                   headers: {
                       'Authorization': `token ${window.appData.token}`,
                       'Accept': 'application/vnd.github.v3+json'
                   }
               });
               
               if (response.ok) {
                   const data = await response.json();
                   const content = decodeBase64(data.content);
                   
                   if (content && content.trim().length > 10) {
                       displayResult(content);
                       addLog('‚úÖ GitHub APIËé∑ÂèñÊàêÂäüÔºÅ', 'success');
                       showToast('üéâ Ëß£ÂØÜÊàêÂäüÔºÅ');
                       setProgress(0);
                       
                       document.getElementById('output').scrollIntoView({ 
                           behavior: 'smooth', 
                           block: 'center' 
                       });
                       return true;
                   }
               } else if (response.status === 404) {
                   addLog('‚ùå output.jsÊñá‰ª∂‰∏çÂ≠òÂú®', 'warning');
               }
           } catch (error) {
               addLog('GitHub APIÂ§±Ë¥•: ' + error.message, 'warning');
           }
           
           try {
               const rawUrl = `https://raw.githubusercontent.com/${window.appData.repo}/main/output.js?_=${timestamp}`;
               const response = await fetch(rawUrl);
               
               if (response.ok) {
                   const content = await response.text();
                   if (content && content.trim().length > 10) {
                       displayResult(content);
                       addLog('‚úÖ Raw URLËé∑ÂèñÊàêÂäüÔºÅ', 'success');
                       showToast('üéâ Ëß£ÂØÜÊàêÂäüÔºÅ');
                       setProgress(0);
                       return true;
                   }
               }
           } catch (error) {
               addLog('Raw URLÂ§±Ë¥•: ' + error.message, 'warning');
           }
           
           addLog('‚ùå Ëé∑ÂèñÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï', 'error');
           showToast('‚ùå Ëé∑ÂèñÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
           return false;
       }
       
       function decodeBase64(base64) {
           try {
               const binaryString = atob(base64.replace(/\n/g, ''));
               const bytes = new Uint8Array(binaryString.length);
               for (let i = 0; i < binaryString.length; i++) {
                   bytes[i] = binaryString.charCodeAt(i);
               }
               return new TextDecoder('utf-8').decode(bytes);
           } catch (e) {
               return atob(base64.replace(/\n/g, ''));
           }
       }
       
       function beautifyJavaScript(code) {
            // ÁßªÈô§Â§ö‰ΩôÁöÑÁ©∫Ê†ºÂíåÊç¢Ë°å
            let beautified = code.replace(/\s+/g, ' ').trim();
            
            // Âú®ÂàÜÂè∑„ÄÅÂ§ßÊã¨Âè∑ÂêéÊ∑ªÂä†Êç¢Ë°å
            beautified = beautified.replace(/;/g, ';\n');
            beautified = beautified.replace(/\{/g, '{\n');
            beautified = beautified.replace(/\}/g, '\n}\n');
            beautified = beautified.replace(/,\s*(?=[a-zA-Z_$\[])/g, ',\n');
            
            // ‰øÆÂ§çÂ∏∏ËßÅÁöÑÊ†ºÂºèÈóÆÈ¢ò
            beautified = beautified.replace(/\n\s*\n/g, '\n'); // ÁßªÈô§Á©∫Ë°å
            beautified = beautified.replace(/;\s*\n\s*\}/g, ';\n}'); // ‰øÆÂ§çÂàÜÂè∑ÂêéÁöÑÊã¨Âè∑
            
            const lines = beautified.split('\n');
            const result = [];
            let indentLevel = 0;
            const indent = '  '; // 2‰∏™Á©∫Ê†ºÁº©Ëøõ
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂáèÂ∞ëÁº©Ëøõ
                if (line.includes('}') && !line.includes('{')) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }
                
                // Ê∑ªÂä†Áº©Ëøõ
                let indentedLine = indent.repeat(indentLevel) + line;
                
                // ÁâπÊÆäÂ§ÑÁêÜÂØπË±°Â±ûÊÄß
                if (line.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*\s*:/)) {
                    // ËøôÊòØÂØπË±°Â±ûÊÄßÔºå‰øùÊåÅÈ¢ùÂ§ñÁº©Ëøõ
                    if (indentLevel > 0) {
                        indentedLine = indent.repeat(indentLevel) + line;
                    }
                }
                
                result.push(indentedLine);
                
                // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂ¢ûÂä†Áº©Ëøõ
                if (line.includes('{') && !line.includes('}')) {
                    indentLevel++;
                } else if (line.includes('=') && line.includes('{') && !line.includes('}')) {
                    indentLevel++;
                }
            }
            
            // ÊúÄÁªàÊ†ºÂºèÂåñÂ§ÑÁêÜ
            let formatted = result.join('\n');
            
            // Ê∑ªÂä†Ê≥®ÈáäÂ§¥ÈÉ®
            const timestamp = new Date().toLocaleString();
            const header = `//Ëß£ÂØÜÊó∂Èó¥: ${timestamp}\n//Ëß£ÂØÜÂ∑•ÂÖ∑: ÁæäÊØõÂä©Êâã v6.0\n//Ëß£ÂØÜÊèí‰ª∂: eval\n\n`;
            
            // ÁâπÊÆäÊ†ºÂºèÂåñÂ§ÑÁêÜ
            formatted = formatted
                .replace(/(\w+)\s*=\s*\{/g, '$1 = {') // Ê†áÂáÜÂåñÂØπË±°ËµãÂÄº
                .replace(/\{\s*\n\s*\}/g, '{}') // Á©∫ÂØπË±°ÂçïË°å
                .replace(/\[\s*\n\s*\]/g, '[]') // Á©∫Êï∞ÁªÑÂçïË°å
                .replace(/,\s*\]/g, ',\n]') // Êï∞ÁªÑÁªìÂ∞æÊ†ºÂºèÂåñ
                .replace(/\{\s*([^}]{1,50})\s*\}/g, '{ $1 }') // Áü≠ÂØπË±°ÂçïË°å
                .replace(/\n{3,}/g, '\n\n'); // ÈôêÂà∂ËøûÁª≠Á©∫Ë°å
            
            return header + formatted;
        }
        
        function beautifyCode() {
            const output = document.getElementById('output');
            let content = output.innerHTML.includes('<span') ? 
                          stripHTMLTags(output.innerHTML) : 
                          output.textContent;
            
            if (!content || content.includes('Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå')) {
                showToast('ËØ∑ÂÖàËé∑ÂèñËß£ÂØÜÁªìÊûú');
                return;
            }
            
            try {
                const beautified = beautifyJavaScript(content);
                displayResult(beautified);
                showToast('üé® ‰ª£Á†ÅÁæéÂåñÂÆåÊàê');
                addLog('‰ª£Á†ÅÁæéÂåñÊàêÂäü', 'success');
                
                // ÊªöÂä®Âà∞ÁªìÊûúÂå∫Âüü
                document.getElementById('output').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            } catch (error) {
                showToast('‚ùå ‰ª£Á†ÅÁæéÂåñÂ§±Ë¥•: ' + error.message);
                addLog('‰ª£Á†ÅÁæéÂåñÂ§±Ë¥•: ' + error.message, 'error');
            }
        }
        
        function stripHTMLTags(html) {
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }
       
       function copyResult() {
           const output = document.getElementById('output');
           let content;
           
           if (output.innerHTML.includes('<span')) {
               content = stripHTMLTags(output.innerHTML);
           } else {
               content = output.textContent || output.innerText;
           }
           
           if (!content || content.includes('Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå')) {
               showToast('‚ùå Ê≤°ÊúâÂèØÂ§çÂà∂ÁöÑÂÜÖÂÆπ');
               return;
           }
           
           if (navigator.clipboard) {
               navigator.clipboard.writeText(content).then(() => {
                   showToast('üìã ÁªìÊûúÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
                   addLog('Â§çÂà∂ÊàêÂäü', 'success');
               }).catch(() => {
                   fallbackCopy(content);
               });
           } else {
               fallbackCopy(content);
           }
       }
       
       function fallbackCopy(content) {
           const textarea = document.createElement('textarea');
           textarea.value = content;
           textarea.style.position = 'fixed';
           textarea.style.opacity = '0';
           document.body.appendChild(textarea);
           textarea.select();
           document.execCommand('copy');
           document.body.removeChild(textarea);
           showToast('üìã ÁªìÊûúÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø');
           addLog('Â§çÂà∂ÊàêÂäüÔºàÂ§áÁî®ÊñπÊ°àÔºâ', 'success');
       }
       
       function downloadResult() {
           const output = document.getElementById('output');
           let content;
           
           if (output.innerHTML.includes('<span')) {
               content = stripHTMLTags(output.innerHTML);
           } else {
               content = output.textContent || output.innerText;
           }
           
           if (!content || content.includes('Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå')) {
               showToast('‚ùå Ê≤°ÊúâÂèØ‰∏ãËΩΩÁöÑÂÜÖÂÆπ');
               return;
           }
           
           try {
               const blob = new Blob([content], { type: 'text/javascript;charset=utf-8' });
               const url = URL.createObjectURL(blob);
               const a = document.createElement('a');
               const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
               
               let filename = `decrypted_${timestamp}.js`;
               if (window.appData.isAAEncodeMode && window.appData.isEvalMode) {
                   filename = `decrypted_mixed_${timestamp}.js`;
               } else if (window.appData.isAAEncodeMode) {
                   filename = `decrypted_aaencode_${timestamp}.js`;
               } else if (window.appData.isEvalMode) {
                   filename = `decrypted_eval_${timestamp}.js`;
               }
               
               a.href = url;
               a.download = filename;
               a.style.display = 'none';
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               URL.revokeObjectURL(url);
               
               showToast('üíæ Êñá‰ª∂‰∏ãËΩΩÂ∑≤ÂºÄÂßã');
               addLog('‰∏ãËΩΩÊàêÂäü', 'success');
           } catch (error) {
               addLog('‰∏ãËΩΩÂ§±Ë¥•: ' + error.message, 'error');
               showToast('‚ùå ‰∏ãËΩΩÂ§±Ë¥•');
           }
       }
       
       function validateResult() {
           const output = document.getElementById('output');
           let content = output.innerHTML.includes('<span') ? 
                         stripHTMLTags(output.innerHTML) : 
                         output.textContent;
           
           if (!content || content.includes('Ëß£ÂØÜÁªìÊûúÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå')) {
               showToast('ËØ∑ÂÖàËé∑ÂèñËß£ÂØÜÁªìÊûú');
               return;
           }
           
           try {
               new Function(content);
               showToast('‚úÖ JavaScriptËØ≠Ê≥ïÊ£ÄÊü•ÈÄöËøá');
               addLog('‰ª£Á†ÅËØ≠Ê≥ïÈ™åËØÅÊàêÂäü', 'success');
           } catch (error) {
               showToast('‚ö†Ô∏è JavaScriptËØ≠Ê≥ïÊ£ÄÊü•Â§±Ë¥•: ' + error.message);
               addLog('‰ª£Á†ÅËØ≠Ê≥ïÈ™åËØÅÂ§±Ë¥•: ' + error.message, 'warning');
           }
       }
       
       function clearAll() {
           document.getElementById('input').value = '';
           displayResult('');
           setProgress(0);
           updateDetectionPanel({ primaryType: 'Unknown' });
           
           showToast('üóë Â∑≤Ê∏ÖÈô§ÊâÄÊúâÂÜÖÂÆπ');
           addLog('Ê∏ÖÈô§ÊâÄÊúâÂÜÖÂÆπ', 'info');
           
           window.scrollTo({ top: 0, behavior: 'smooth' });
       }
       
       function handleFileSelect(event) {
           const file = event.target.files[0];
           if (file) {
               readFile(file);
           }
       }
       
       function handleDragOver(event) {
           event.preventDefault();
           event.currentTarget.classList.add('dragover');
       }
       
       function handleDragLeave(event) {
           event.currentTarget.classList.remove('dragover');
       }
       
       function handleDrop(event) {
           event.preventDefault();
           event.currentTarget.classList.remove('dragover');
           
           const files = event.dataTransfer.files;
           if (files.length > 0) {
               readFile(files[0]);
           }
       }
       
       function readFile(file) {
           addLog(`üìÅ ÂºÄÂßãËØªÂèñÊñá‰ª∂: ${file.name}`, 'info');
           
           const reader = new FileReader();
           reader.onload = function(e) {
               try {
                   let content = e.target.result;
                   
                   document.getElementById('input').value = content;
                   showToast(`üìÅ Êñá‰ª∂Âä†ËΩΩÊàêÂäü: ${file.name}`);
                   addLog(`Êñá‰ª∂Âä†ËΩΩÊàêÂäü (${content.length} Â≠óÁ¨¶)`, 'success');
                   
                   setTimeout(() => {
                       const detection = comprehensiveDetection(content);
                       updateDetectionPanel(detection);
                       if (detection.primaryType !== 'Unknown') {
                           showToast(`üéØ Ê£ÄÊµãÂà∞${detection.primaryType}Êñá‰ª∂ÔºÅÁΩÆ‰ø°Â∫¶: ${detection.primaryConfidence}%`);
                       }
                   }, 500);
                   
               } catch (error) {
                   addLog(`Êñá‰ª∂Â§ÑÁêÜÂ§±Ë¥•: ${error.message}`, 'error');
                   showToast('‚ùå Êñá‰ª∂Â§ÑÁêÜÂ§±Ë¥•');
               }
           };
           
           reader.onerror = function() {
               addLog(`Êñá‰ª∂ËØªÂèñÂ§±Ë¥•: ${file.name}`, 'error');
               showToast('‚ùå Êñá‰ª∂ËØªÂèñÂ§±Ë¥•');
           };
           
           reader.readAsText(file, 'UTF-8');
       }
       
       function addLog(message, type = 'info') {
           const logs = document.getElementById('logs');
           const time = new Date().toLocaleTimeString();
           const div = document.createElement('div');
           div.className = 'log-' + type;
           div.textContent = `${time} ${message}`;
           logs.appendChild(div);
           logs.scrollTop = logs.scrollHeight;
           
           if (logs.children.length > 50) {
               logs.removeChild(logs.firstChild);
           }
       }
       
       function showToast(message, duration = 3000) {
           const toast = document.getElementById('toast');
           toast.textContent = message;
           toast.classList.add('show');
           setTimeout(() => toast.classList.remove('show'), duration);
       }
       
       document.addEventListener('DOMContentLoaded', function() {
           document.getElementById('token').value = window.appData.token;
           document.getElementById('repo').value = window.appData.repo;
           
           document.getElementById('token').addEventListener('input', function(e) {
               window.appData.token = e.target.value;
               localStorage.setItem('github_token', e.target.value);
           });
           
           document.getElementById('repo').addEventListener('input', function(e) {
               window.appData.repo = e.target.value;
               localStorage.setItem('repo_name', e.target.value);
           });
           
           document.getElementById('fileInput').addEventListener('change', handleFileSelect);
           
           const fileUpload = document.querySelector('.file-upload');
           fileUpload.addEventListener('dragover', handleDragOver);
           fileUpload.addEventListener('dragleave', handleDragLeave);
           fileUpload.addEventListener('drop', handleDrop);
           
           document.getElementById('input').addEventListener('input', function() {
               const input = this.value.trim();
               if (input.length > 50) {
                   const detection = comprehensiveDetection(input);
                   updateDetectionPanel(detection);
               } else {
                   updateDetectionPanel({ primaryType: 'Unknown' });
               }
           });
           
           document.addEventListener('keydown', function(e) {
               if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                   e.preventDefault();
                   startDecrypt();
               } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                   e.preventDefault();
                   downloadResult();
               } else if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !e.target.matches('input, textarea')) {
                   e.preventDefault();
                   copyResult();
               } else if (e.key === 'Escape') {
                   e.preventDefault();
                   clearAll();
               }
           });
           
           addLog(`üöÄ Á≥ªÁªüÂàùÂßãÂåñÂÆåÊàê v${APP_CONFIG.VERSION}`, 'success');
           addLog('üéØ ‰∏ì‰∏öAADecodeÊèí‰ª∂Â∑≤Âä†ËΩΩÔºåÊîØÊåÅÂ§¥ÈÉ®Ê≥®Èáä‰øùÁïô', 'info');
           addLog('üîß ‰∏ì‰∏öEvalËß£ÂåÖÊèí‰ª∂Â∑≤Âä†ËΩΩÔºåÊîØÊåÅÈÄíÂΩíËß£ÂØÜ', 'info');
           addLog('üí° Âø´Êç∑ÈîÆ: Ctrl+EnterËß£ÂØÜ, Ctrl+S‰∏ãËΩΩ, Ctrl+CÂ§çÂà∂, EscÊ∏ÖÈô§', 'info');
       });
       
       window.addEventListener('error', function(e) {
           addLog('‚ùå ÂèëÁîüÈîôËØØ: ' + e.message, 'error');
           console.error('Global error:', e);
       });
       
       window.addEventListener('unhandledrejection', function(e) {
           addLog('‚ùå PromiseÈîôËØØ: ' + e.reason, 'error');
           console.error('Unhandled promise rejection:', e);
       });
   </script>
</body>
</html>